#!/usr/bin/php
<?php

include "storage.php";

error_reporting(E_ERROR);
define('MAX_PROCESS_NUM', 100);
define('TIMEOUT',120);

function myexec($cmd, $run) {
	echo "$cmd\n";
	if ( $run ) {
		$output = array();
		exec($cmd, $output);
		if ( count($output) > 0 ) {
			print_r($output);
		}
	}
}

echo "start " . date("Y/m/d H:i:s") ."\n";

getWolkDatabase(true);

//For AWS Debugging:
// $sql = "select publicip, datacenter, cloudprovider from servers where pushwolk=1 and consensus=1 and cloudprovider='aws'";
$sql = "select hostname, publicip, datacenter, cloudprovider, consensus, nodenumber from servers where pushwolk=1 order by nodenumber";
//$sql .= " and consensus = 1";
if ( $res = mysql_query($sql) ) {
	while ( $a = mysql_fetch_object($res) ) {
		$servers[] = $a;
	}
} else {
	echo mysql_error();
	exit(0);
}

$stage = isset($argv[1]) ? $argv[1] : 1; // stage [0-5]
$arg2 = isset($argv[2]) ? $argv[2] : ""; // use [restart] to restart the chain from genesis, or prvide a nodelist [1,3,4..] to resume certain nodes from wehre it left off
$restart = "";
if ($arg2 == "restart") {
	$restart = "restart";
}else if ($arg2 != "") {
	$fmt = array(",","[","]");
	$valid_input = is_numeric(str_replace($fmt, "", $arg2));
	if ($valid_input) {
		$nodestr = str_replace(array("[","]"), "", $arg2);
		if (substr($nodestr, -1) != ",") {
			$nodeIDs = array_map('intval', explode(',', $nodestr));
		}
	}else{
		echo "Invalid nodeIDs\n";
	}
}

foreach ($servers as $i => $s) {
	if (in_array($s->nodenumber, $nodeIDs)){
		$serversToPush[] = $s;
	}
}

if (count($serversToPush) == 0 && strlen($arg2) == 0 ) {
	 $serversToPush = $servers; // push to all servers if nodeID not specified 
}

echo print_r($serversToPush);
echo "[$restart]\n";
$httpport = 80 + $stage;
$rpcport = 9900 + $stage;
$p2pport = 30300 + 1000*$stage;
$maindir = "/root/go/src/github.com/wolkdb/cloudstore";
$creddir = "$maindir/wolk/cloud/credentials";
$genesis = "$creddir/genesis$stage.json";
$ts = date("Y-m-d", time()).$stage;
$SkipLocalGetChunk = 0;
echo "Seed $seed_16 ($seed_64)\n";

$args[servers] = $serversToPush; //was $servers;
$args[stage] = $stage;
$args[restart] = $restart;
$mp = new MultiProcess($args);
$ext = new extFunc();
$mp->setWork(array($ext, "wolk"));
$mp->run();
echo "finish " . date("Y/m/d H:i:s") ."\n";


class MultiProcess
{
	private $args;
	private $maxProcessNum;

	public function setWork($callback)
	{
		$this->work = $callback;
	}

	public function __construct($args)
	{
	$maxProcessNum = MAX_PROCESS_NUM;
		$this->args		  = $args;
		$this->maxProcessNum = $maxProcessNum;

		pcntl_signal(SIGTERM, array($this, 'sigHandler'));
		pcntl_signal(SIGHUP,  array($this, 'sigHandler'));
		pcntl_signal(SIGUSR1, array($this, 'sigHandler'));
		pcntl_signal(SIGALRM, array($this, 'sigHandler'));

	}

	private function sigHandler($signo)
	{
		switch ($signo)
		{
			case SIGTERM:
				echo "shutdown...\n";
				exit;
				break;
			case SIGHUP:
				echo "reboot...\n";
				break;
			case SIGUSR1:
				echo "SIGUSER($signo)\n";
				break;
			case SIGALRM:
				echo "alarm...\n";
				exit;
				break;
			default:
				echo "Other signal: " . $signo . "\n";
		}
	}

	public function run()
	{
		$pchild = 0;
		$pnum = 0;
		$pend = 0;

		$servers = $this->args[servers];
		$servercount;
		foreach ($servers as $i => $s) {
			$servercount++;
			if( $pchild < $this->maxProcessNum)
			{
				$pid = pcntl_fork();

				if ($pid == -1)
				{
					throw new Exception('Failed forc process.');
				}
				else if ($pid)
				{
					$pchild++;
					$pnum++;
				}
				else
				{
					$arg[servers] = $s;
					$arg[stage] = $this->args[stage];
					$arg[restart] = $this->args[restart];

					pcntl_alarm(TIMEOUT);

					if (!is_array($this->work))
					{
						$function = $this->work;
						$function($arg);
					}
					else
					{
						$obj  = $this->work[0];
						$func = $this->work[1];
						$obj->$func($arg);
					}
					exit(0);
				}
			}
			else
			{
				echo "waiting.\n";
				$pid = pcntl_waitpid(-1, $status, WUNTRACED);
				$pchild--;
				$pend++;

				echo "$pid stopped.\n";
			}
		}
		echo "kicked all.\n";
		while (pcntl_waitpid(0, $status) != -1) {
			$status = pcntl_wexitstatus($status);
			//echo "Child $status completed\n";
		}
	}
}

class extFunc
{
	function wolk($args)
	{
		global $seed_64;
		$stage = $args[stage];
		$s = $args[servers];
		$restart = $args[restart];
		$httpport = 80 + $stage;
		if ( $stage == 0 ) {
			$httpport = 443;
		}
		$rpcport = 9900 + $stage;
		$p2pport = 30300 + 1000*$stage;
		$maindir = "/root/go/src/github.com/wolkdb/cloudstore";
		$creddir = "$maindir/wolk/cloud/credentials";

		$hostname = $s->hostname;
		$consensusidx = $s->nodenumber;
		$server = $s->publicip;
		$dc = $s->datacenter;
		if ( $s->cloudprovider == "gc" ) {
			if ( strstr($dc, "us-west") ) {
				$region = "us-west2";
				$project = "wolk-us-west";
			} else if ( strstr($dc, "us-east") ) {
				$region = "us-east4";
				$project = "wolk-us-east";
			} else if ( strstr($dc, "us-central") ) {
				$region = "us-central";
				$project = "wolk-us-central";
			} else if ( strstr($dc, "asia-east") ) {
				$region = "asia-east2";
				$project = "wolk-asia-east";
			} else if ( strstr($dc, "europe-west") ) {
				$region = "europe-west3";
				$project = "wolk-europe-west";
			} else if ( strstr($dc, "asia-south") ) {
				$region = "asia-south";
				$project = "wolk-asia-south";
			} else if ( strstr($dc, "northamerica-northeast") ) {
		  		$region = "northamerica-northeast";
		  		$project = "wolk-northamerica-northeast";
			} else if ( strstr($dc, "southamerica-east") ) {
		  		$region = "southamerica-east";
		  		$project = "wolk-southamerica-east";
			}
  	} else {
			$region = $s->datacenter;
  	}
		$toml = array();
		echo "consensus " .  $s->consensus . "consensusidx ". $consensusidx . "server". $server. "\n";
		if ( $s->consensus > 0 ) {
		  $toml[] = "ConsensusIdx = ".$consensusidx;
		}
		$genesis = "$creddir/genesis$stage.json";
		if ( $stage == 99 ) {
			$toml[] = "ConsensusAlgorithm = \"roundrobinpoa\"";
		} else {
			$toml[] = "ConsensusAlgorithm = \"poa\"";
		}
		$toml[] = "GenesisFile = \"$genesis\"";
		if ( $SkipLocalGetChunk > 0 ) {
			$toml[] = "SkipLocalGetChunk = $SkipLocalGetChunk";
		}
		if( $stage != 1 ) {
			$toml[] = "SSLCertFile = \"/etc/ssl/certs/wildcard.wolk.com/www.wolk.com.crt\"";
			$toml[] = "SSLKeyFile = \"/etc/ssl/certs/wildcard.wolk.com/www.wolk.com.key\"";
		}
		if ( $s->cloudprovider == "gc" ) {
			$toml[] = "Provider = \"google_datastore\"";
			$toml[] = "Region = \"$region\"";
			$toml[] = "GoogleDatastoreProject = \"$project\"";
			$toml[] = "GoogleDatastoreCredentials = \"/root/go/src/github.com/wolkdb/cloudstore/wolk/cloud/credentials/google.json\"";
		} else if ( $s->cloudprovider == "azure" ) {
			$toml[] = "Provider = \"microsoft_azure\"";
			$toml[] = "Region = \"$region\"";
//			$toml[] = "MicrosoftAzureAccountName = \"wolkaz\"";
//			$toml[] = "MicrosoftAzureAccountKey = \"\"";
		} else {
			$toml[] = "Provider = \"amazon_dynamo\"";
			$toml[] = "AmazonRegion = \"$region\""; // us-west-2
			$toml[] = "AmazonCredentials = \"/root/.aws/credentials\"";
		}
		$tomlstr = implode("\n", $toml);

		// set up a list of commands
		$binary = "wolk$stage";
		$logfile = "/var/log/$binary.log";

		if ( $restart == "restart" ) {
   			$localdb = "/usr/local/wolk$stage";
		} else {
   			$localdb = "";
		}
		// copy the TOML file
		$cp_toml = "/tmp/wolk$stage$server.toml";
		$dst_toml = "$maindir/wolk$stage.toml";
		file_put_contents($cp_toml, $tomlstr);

		// kill pre-existing binary running, remove pre-existing log
		$cmds = array();
		$cmds[] = "ssh $server 'kill -9 $(pidof $binary)' &";
		$cmds[] = "ssh $server 'rm -rf $logfile $localdb/*db' &";
		$cmds[] = "scp $cp_toml $server:$dst_toml &";

		// copy the binary
		$src_binary = "$maindir/build/bin/wolk";
		$dst_binary = "$maindir/build/bin/$binary";
		if ( ! file_exists($src_binary) ) {
   			echo "$src_binary does not exist! Terminating...\n";
		} else {
   			$cmds[] = "scp $src_binary $server:$dst_binary";
		}

		// start binary
		$datadir = "/usr/local/wolk$stage";
		$flags = array();
		$flags[] = "--verbosity=6 --datadir $datadir --rpc --rpcaddr 0.0.0.0 --rpccorsdomain=* --rpcvhosts=* --rpcport $rpcport --port $p2pport --httpport $httpport";

/*
0 - non-preemptive, poa, validate transition
1 - preemptive, poa, validate transition  [HTTP]
2 - preemptive, roundrobinpoa, validate transition  [HTTPS]
3 - no pushing right now, do not validate transition
4 - Yaron investigations on sync blocks/certificates [HTTPS]
5 - non-preemptive, roundrobinpoa, validate transition [HTTPS]
*/
		switch ($stage) {
			case 0:
				$flags[] = "--wolklog nothing";
				break;
			case 1:
				$flags[] = "--wolklog nothing";
				break;
			case 2:
				$flags[] = "--wolklog nothing";
				break;
			case 3:
				$flags[] = "--wolklog nothing";
				break;
			case 4:
				$flags[] = "--wolklog backend";
				break;
			case 5:
				$flags[] = "--wolklog nothing";
				break;
			default:
				// $flags[] = "--wolklog http,handler";
				$flags[] = "--wolklog backend";
				break;
		}

		if ( file_exists($cp_toml) ) {
	 		$flags[] = "--config $dst_toml";
		}
		$fullcmd = "$maindir/build/bin/wolk$stage ".implode(" ", $flags);
		$cmds[] = "ssh $server '$fullcmd >> $logfile 2>&1 &'";

		// NOW, put it all together
		foreach ($cmds as $cmd) {
   			// $pushstaginglog = "/var/log/pushstaging.log";
   			//$c = implode($cmds, " && ")." ";
   			myexec($cmd, true);
		}
	}
}

// run these after successful restarts
if ( ( $stage == 1 ) && ( strlen($restart) > 0 ) ) {
  $cmds = array();
  $cmds[] = "rm -rf /root/go/src/github.com/wolkdb/keys/*";  // PROBLEM -- private key not consistent across restarts
  $cmds[] = "wcloud -httpport=81 createaccount dweb.archive.org";  // PROBLEM -- private key not consistent across restarts
  $cmds[] = "wcloud -httpport=81 createcoll wolk://dweb.archive.org/metadata http://d2.wolk.com/dweb.archive.org";
  foreach ($cmds as $c) {
      sleep(15);
      echo "$c\n";
      exec($c, $arr);
      print_r($arr);
  }
}
?>
