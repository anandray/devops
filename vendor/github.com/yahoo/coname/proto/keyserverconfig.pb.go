// Code generated by protoc-gen-gogo.
// source: keyserverconfig.proto
// DO NOT EDIT!

package proto

import proto1 "github.com/maditya/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/maditya/protobuf/gogoproto"

import bytes "bytes"

import strings "strings"
import github_com_maditya_protobuf_proto "github.com/maditya/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ReplicaConfig contains the local configuration of a single replica of a
// keyserver. It is valid to have just one replica, but a larger odd number is
// desirable for availability.
type ReplicaConfig struct {
	KeyserverConfig `protobuf:"bytes,1,opt,name=keyserver_config,json=keyserverConfig,embedded=keyserver_config" json:"keyserver_config"`
	// ReplicaID is a globally unique identifier. See Replica.ID.
	ReplicaID uint64 `protobuf:"varint,2,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	// SigningKeyID specifies the signing key by reference. The mechanism of
	// loading keys depends on the deployment scenario; by default, the key
	// identifier is a path to a file containing the key.
	SigningKeyID  string    `protobuf:"bytes,3,opt,name=signing_key_id,json=signingKeyId,proto3" json:"signing_key_id,omitempty"`
	PublicAddr    string    `protobuf:"bytes,4,opt,name=public_addr,json=publicAddr,proto3" json:"public_addr,omitempty"`
	PublicTLS     TLSConfig `protobuf:"bytes,5,opt,name=public_tls,json=publicTls" json:"public_tls"`
	VerifierAddr  string    `protobuf:"bytes,6,opt,name=verifier_addr,json=verifierAddr,proto3" json:"verifier_addr,omitempty"`
	VerifierTLS   TLSConfig `protobuf:"bytes,7,opt,name=verifier_tls,json=verifierTls" json:"verifier_tls"`
	HKPAddr       string    `protobuf:"bytes,8,opt,name=hkp_addr,json=hkpAddr,proto3" json:"hkp_addr,omitempty"`
	HKPTLS        TLSConfig `protobuf:"bytes,9,opt,name=hkp_tls,json=hkpTls" json:"hkp_tls"`
	HTTPFrontAddr string    `protobuf:"bytes,10,opt,name=httpfront_addr,json=httpfrontAddr,proto3" json:"httpfront_addr,omitempty"`
	HTTPFrontTLS  TLSConfig `protobuf:"bytes,11,opt,name=httpfront_tls,json=httpfrontTls" json:"httpfront_tls"`
	RaftAddr      string    `protobuf:"bytes,12,opt,name=raft_addr,json=raftAddr,proto3" json:"raft_addr,omitempty"`
	RaftTLS       TLSConfig `protobuf:"bytes,13,opt,name=raft_tls,json=raftTls" json:"raft_tls"`
	// LevelDBPath specifies the directory in which the database is stored.
	// Nothing else should use this directory.
	LevelDBPath string `protobuf:"bytes,14,opt,name=leveldb_path,json=leveldbPath,proto3" json:"leveldb_path,omitempty"`
	// RaftHeartbeat specifies the interval between successive heartbeat
	// messages sent by the replicated state machine controller. Lowering the
	// heartbeat interval generates more network traffic; increasing the
	// interval increases the time it takes to detect a failed replica and
	// perform an automated failover.
	RaftHeartbeat Duration `protobuf:"bytes,15,opt,name=raft_heartbeat,json=raftHeartbeat" json:"raft_heartbeat"`
	// LaggingVerifierScan specifies the maximum number of epochs by which a
	// verifier can be lagging us for us to still serve its signature to
	// clients. Finding the verifier signatures is currently implemented using a
	// linear scan backwards from the current epoch, so setting a very high
	// value can open up cause significant amounts of database reads on the
	// server. A fancy index-based scan would be possible, but there is no
	// clear need for it -- the epochs far in the past will probably have
	// expired anyway. The zero value means no limit, but it should be used for
	// testing only. The recommended value is 1000.
	LaggingVerifierScan uint64 `protobuf:"varint,16,opt,name=lagging_verifier_scan,json=laggingVerifierScan,proto3" json:"lagging_verifier_scan,omitempty"`
	// ClientTimeout specifies the maximum amount of time the server is willing
	// to allow from the start of a client request to until it is handled. The
	// zero value means no limit.
	ClientTimeout Duration `protobuf:"bytes,17,opt,name=client_timeout,json=clientTimeout" json:"client_timeout"`
}

func (m *ReplicaConfig) Reset()                    { *m = ReplicaConfig{} }
func (*ReplicaConfig) ProtoMessage()               {}
func (*ReplicaConfig) Descriptor() ([]byte, []int) { return fileDescriptorKeyserverconfig, []int{0} }

func (m *ReplicaConfig) GetPublicTLS() TLSConfig {
	if m != nil {
		return m.PublicTLS
	}
	return TLSConfig{}
}

func (m *ReplicaConfig) GetVerifierTLS() TLSConfig {
	if m != nil {
		return m.VerifierTLS
	}
	return TLSConfig{}
}

func (m *ReplicaConfig) GetHKPTLS() TLSConfig {
	if m != nil {
		return m.HKPTLS
	}
	return TLSConfig{}
}

func (m *ReplicaConfig) GetHTTPFrontTLS() TLSConfig {
	if m != nil {
		return m.HTTPFrontTLS
	}
	return TLSConfig{}
}

func (m *ReplicaConfig) GetRaftTLS() TLSConfig {
	if m != nil {
		return m.RaftTLS
	}
	return TLSConfig{}
}

func (m *ReplicaConfig) GetRaftHeartbeat() Duration {
	if m != nil {
		return m.RaftHeartbeat
	}
	return Duration{}
}

func (m *ReplicaConfig) GetClientTimeout() Duration {
	if m != nil {
		return m.ClientTimeout
	}
	return Duration{}
}

// KeyserverConfig describes the keyserver-wide configuration. All replicas
// MUST use the same KeyserverConfig.
type KeyserverConfig struct {
	// ServerID is deprecated and should not be used. TODO: remove.  Signatures
	// should be tagged with ReplicaIDs, and the realm can be used to refer to
	// the keyserver as a whole.
	ServerID uint64 `protobuf:"varint,1,opt,name=server_id,json=serverId,proto3" json:"server_id,omitempty"`
	// Realm specifies the general set of users whose keys this keyserver
	// manages. If the user identifiers are email addresses, the realm should
	// match the domain name in the email address.
	Realm string `protobuf:"bytes,2,opt,name=realm,proto3" json:"realm,omitempty"`
	// SigningKeyID specifies the key for the verifiable random function by
	// reference. The mechanism of loading keys depends on the deployment
	// scenario; by default, the key identifier is a path to a file containing
	// the key.
	VRFKeyID string `protobuf:"bytes,3,opt,name=vrf_key_id,json=vrfKeyId,proto3" json:"vrf_key_id,omitempty"`
	// MinEpochInterval specifies the time for which the keyserver stops
	// proposing new epochs once an epoch has been committed. The zero value
	// means no delay. After MinEpochInterval since the last epoch, the
	// keyserver will propose a new epoch as soon as an update has been
	// committed.
	MinEpochInterval Duration `protobuf:"bytes,4,opt,name=min_epoch_interval,json=minEpochInterval" json:"min_epoch_interval"`
	// MaxEpochInterval specifies the time after which the keyserver will
	// propose a new epoch even if there have been no updates since the last
	// epoch. Vouching for the lack of updates is important to ensure the users
	// that none of the served keys have been revoked. This value is a trigger,
	// NOT a deadline; there is no guarantee that consecutive epochs will be at
	// most MaxEpochInterval apart. The actual time between by epochs is
	// MaxEpochInterval plus however long it takes to commit and sign a new
	// epoch.
	MaxEpochInterval Duration `protobuf:"bytes,5,opt,name=max_epoch_interval,json=maxEpochInterval" json:"max_epoch_interval"`
	// ProposalRetryInterval specifies the time after an unsuccessful proposal
	// after which the proposal will be retried. A lower value will generate
	// more redundant network traffic while a higher value will improve
	// responsiveness in presence of network or node failures (bounded below by
	// the raft failover time).
	ProposalRetryInterval Duration `protobuf:"bytes,6,opt,name=proposal_retry_interval,json=proposalRetryInterval" json:"proposal_retry_interval"`
	// InitialReplicas contains the cluster configuration at the beginning of
	// time. It MUST NOT be modified ever after, and it MUST be the same for
	// all replicas. Use AddReplica and RemoveReplica to change the current
	// cluster configuration.
	InitialReplicas []*Replica `protobuf:"bytes,7,rep,name=initial_replicas,json=initialReplicas" json:"initial_replicas,omitempty"`
	// Keyserver may support multiple registration policies at a time.
	// A policy is acceptable only for the domains it supports.
	RegistrationPolicy []*RegistrationPolicy `protobuf:"bytes,8,rep,name=registration_policy,json=registrationPolicy" json:"registration_policy,omitempty"`
}

func (m *KeyserverConfig) Reset()                    { *m = KeyserverConfig{} }
func (*KeyserverConfig) ProtoMessage()               {}
func (*KeyserverConfig) Descriptor() ([]byte, []int) { return fileDescriptorKeyserverconfig, []int{1} }

func (m *KeyserverConfig) GetMinEpochInterval() Duration {
	if m != nil {
		return m.MinEpochInterval
	}
	return Duration{}
}

func (m *KeyserverConfig) GetMaxEpochInterval() Duration {
	if m != nil {
		return m.MaxEpochInterval
	}
	return Duration{}
}

func (m *KeyserverConfig) GetProposalRetryInterval() Duration {
	if m != nil {
		return m.ProposalRetryInterval
	}
	return Duration{}
}

func (m *KeyserverConfig) GetInitialReplicas() []*Replica {
	if m != nil {
		return m.InitialReplicas
	}
	return nil
}

func (m *KeyserverConfig) GetRegistrationPolicy() []*RegistrationPolicy {
	if m != nil {
		return m.RegistrationPolicy
	}
	return nil
}

// RegistrationPolicy specifies the list of policies the keyserver may support,
// to confirm the ownership of an email address
type RegistrationPolicy struct {
	// Types that are valid to be assigned to PolicyType:
	//	*RegistrationPolicy_InsecureSkipEmailProof
	//	*RegistrationPolicy_EmailProofByDKIM
	//	*RegistrationPolicy_EmailProofByClientCert
	//	*RegistrationPolicy_EmailProofByOIDC
	//	*RegistrationPolicy_EmailProofBySAML
	PolicyType isRegistrationPolicy_PolicyType `protobuf_oneof:"policy_type"`
}

func (m *RegistrationPolicy) Reset()      { *m = RegistrationPolicy{} }
func (*RegistrationPolicy) ProtoMessage() {}
func (*RegistrationPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptorKeyserverconfig, []int{2}
}

type isRegistrationPolicy_PolicyType interface {
	isRegistrationPolicy_PolicyType()
	Equal(interface{}) bool
	VerboseEqual(interface{}) error
	MarshalTo([]byte) (int, error)
	Size() int
}

type RegistrationPolicy_InsecureSkipEmailProof struct {
	InsecureSkipEmailProof bool `protobuf:"varint,1,opt,name=insecure_skip_email_proof,json=insecureSkipEmailProof,proto3,oneof"`
}
type RegistrationPolicy_EmailProofByDKIM struct {
	EmailProofByDKIM *EmailProofByDKIM `protobuf:"bytes,2,opt,name=email_proof_by_dkim,json=emailProofByDkim,oneof"`
}
type RegistrationPolicy_EmailProofByClientCert struct {
	EmailProofByClientCert *EmailProofByClientCert `protobuf:"bytes,3,opt,name=email_proof_by_client_cert,json=emailProofByClientCert,oneof"`
}
type RegistrationPolicy_EmailProofByOIDC struct {
	EmailProofByOIDC *EmailProofByOIDC `protobuf:"bytes,4,opt,name=email_proof_by_oidc,json=emailProofByOidc,oneof"`
}
type RegistrationPolicy_EmailProofBySAML struct {
	EmailProofBySAML *EmailProofBySAML `protobuf:"bytes,5,opt,name=email_proof_by_saml,json=emailProofBySaml,oneof"`
}

func (*RegistrationPolicy_InsecureSkipEmailProof) isRegistrationPolicy_PolicyType() {}
func (*RegistrationPolicy_EmailProofByDKIM) isRegistrationPolicy_PolicyType()       {}
func (*RegistrationPolicy_EmailProofByClientCert) isRegistrationPolicy_PolicyType() {}
func (*RegistrationPolicy_EmailProofByOIDC) isRegistrationPolicy_PolicyType()       {}
func (*RegistrationPolicy_EmailProofBySAML) isRegistrationPolicy_PolicyType()       {}

func (m *RegistrationPolicy) GetPolicyType() isRegistrationPolicy_PolicyType {
	if m != nil {
		return m.PolicyType
	}
	return nil
}

func (m *RegistrationPolicy) GetInsecureSkipEmailProof() bool {
	if x, ok := m.GetPolicyType().(*RegistrationPolicy_InsecureSkipEmailProof); ok {
		return x.InsecureSkipEmailProof
	}
	return false
}

func (m *RegistrationPolicy) GetEmailProofByDKIM() *EmailProofByDKIM {
	if x, ok := m.GetPolicyType().(*RegistrationPolicy_EmailProofByDKIM); ok {
		return x.EmailProofByDKIM
	}
	return nil
}

func (m *RegistrationPolicy) GetEmailProofByClientCert() *EmailProofByClientCert {
	if x, ok := m.GetPolicyType().(*RegistrationPolicy_EmailProofByClientCert); ok {
		return x.EmailProofByClientCert
	}
	return nil
}

func (m *RegistrationPolicy) GetEmailProofByOIDC() *EmailProofByOIDC {
	if x, ok := m.GetPolicyType().(*RegistrationPolicy_EmailProofByOIDC); ok {
		return x.EmailProofByOIDC
	}
	return nil
}

func (m *RegistrationPolicy) GetEmailProofBySAML() *EmailProofBySAML {
	if x, ok := m.GetPolicyType().(*RegistrationPolicy_EmailProofBySAML); ok {
		return x.EmailProofBySAML
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RegistrationPolicy) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _RegistrationPolicy_OneofMarshaler, _RegistrationPolicy_OneofUnmarshaler, _RegistrationPolicy_OneofSizer, []interface{}{
		(*RegistrationPolicy_InsecureSkipEmailProof)(nil),
		(*RegistrationPolicy_EmailProofByDKIM)(nil),
		(*RegistrationPolicy_EmailProofByClientCert)(nil),
		(*RegistrationPolicy_EmailProofByOIDC)(nil),
		(*RegistrationPolicy_EmailProofBySAML)(nil),
	}
}

func _RegistrationPolicy_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*RegistrationPolicy)
	// policy_type
	switch x := m.PolicyType.(type) {
	case *RegistrationPolicy_InsecureSkipEmailProof:
		t := uint64(0)
		if x.InsecureSkipEmailProof {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto1.WireVarint)
		_ = b.EncodeVarint(t)
	case *RegistrationPolicy_EmailProofByDKIM:
		_ = b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.EmailProofByDKIM); err != nil {
			return err
		}
	case *RegistrationPolicy_EmailProofByClientCert:
		_ = b.EncodeVarint(3<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.EmailProofByClientCert); err != nil {
			return err
		}
	case *RegistrationPolicy_EmailProofByOIDC:
		_ = b.EncodeVarint(4<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.EmailProofByOIDC); err != nil {
			return err
		}
	case *RegistrationPolicy_EmailProofBySAML:
		_ = b.EncodeVarint(5<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.EmailProofBySAML); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RegistrationPolicy.PolicyType has unexpected type %T", x)
	}
	return nil
}

func _RegistrationPolicy_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*RegistrationPolicy)
	switch tag {
	case 1: // policy_type.insecure_skip_email_proof
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.PolicyType = &RegistrationPolicy_InsecureSkipEmailProof{x != 0}
		return true, err
	case 2: // policy_type.email_proof_by_dkim
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(EmailProofByDKIM)
		err := b.DecodeMessage(msg)
		m.PolicyType = &RegistrationPolicy_EmailProofByDKIM{msg}
		return true, err
	case 3: // policy_type.email_proof_by_client_cert
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(EmailProofByClientCert)
		err := b.DecodeMessage(msg)
		m.PolicyType = &RegistrationPolicy_EmailProofByClientCert{msg}
		return true, err
	case 4: // policy_type.email_proof_by_oidc
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(EmailProofByOIDC)
		err := b.DecodeMessage(msg)
		m.PolicyType = &RegistrationPolicy_EmailProofByOIDC{msg}
		return true, err
	case 5: // policy_type.email_proof_by_saml
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(EmailProofBySAML)
		err := b.DecodeMessage(msg)
		m.PolicyType = &RegistrationPolicy_EmailProofBySAML{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RegistrationPolicy_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*RegistrationPolicy)
	// policy_type
	switch x := m.PolicyType.(type) {
	case *RegistrationPolicy_InsecureSkipEmailProof:
		n += proto1.SizeVarint(1<<3 | proto1.WireVarint)
		n += 1
	case *RegistrationPolicy_EmailProofByDKIM:
		s := proto1.Size(x.EmailProofByDKIM)
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *RegistrationPolicy_EmailProofByClientCert:
		s := proto1.Size(x.EmailProofByClientCert)
		n += proto1.SizeVarint(3<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *RegistrationPolicy_EmailProofByOIDC:
		s := proto1.Size(x.EmailProofByOIDC)
		n += proto1.SizeVarint(4<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *RegistrationPolicy_EmailProofBySAML:
		s := proto1.Size(x.EmailProofBySAML)
		n += proto1.SizeVarint(5<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EmailProofByDKIM struct {
	// AllowedDomains specifies the domains for which this keyserver accepts
	// email address registrations.
	AllowedDomains []string `protobuf:"bytes,1,rep,name=allowed_domains,json=allowedDomains" json:"allowed_domains,omitempty"`
	// ToAddr specifies the additional allowed to address in email proofs. By
	// default, only proofs sent to the user being registered all accepted.
	// This option can be used to allow proofs emailed directly to the
	// keyserver to be accepted (but the keyserver does NOT implement a SMTP
	// interface right now).
	ToAddr string `protobuf:"bytes,2,opt,name=to_addr,json=toAddr,proto3" json:"to_addr,omitempty"`
	// SubjectPrefix is used for DKIM-based email address registration.  The
	// proof challenge is sent in the subject line, with an optional string
	// preceding it. For example, if EmailProofSubjectPrefix = "account
	// verification: ", then the proof email needs to have a subject line
	// "account verification: abcd" for verify challenge abcd.
	SubjectPrefix string `protobuf:"bytes,3,opt,name=subject_prefix,json=subjectPrefix,proto3" json:"subject_prefix,omitempty"`
}

func (m *EmailProofByDKIM) Reset()                    { *m = EmailProofByDKIM{} }
func (*EmailProofByDKIM) ProtoMessage()               {}
func (*EmailProofByDKIM) Descriptor() ([]byte, []int) { return fileDescriptorKeyserverconfig, []int{3} }

// EmailProofByClientCert accepts a certificate signed by an authority trusted
// with handling registration as sufficient confirmation of ownership of an
// email address. The emailAddress value in the certificate's DistinguishedName
// field is allowed to be registered by the holder of the key specified in the
// certificate.
type EmailProofByClientCert struct {
	// AllowedDomains specifies the domains for which this keyserver accepts
	// email address registrations by this policy.
	AllowedDomains []string `protobuf:"bytes,1,rep,name=allowed_domains,json=allowedDomains" json:"allowed_domains,omitempty"`
	// CaCert contains the trusted certificate authority certificate in DER format.
	CaCert []byte `protobuf:"bytes,2,opt,name=ca_cert,json=caCert,proto3" json:"ca_cert,omitempty"`
}

func (m *EmailProofByClientCert) Reset()      { *m = EmailProofByClientCert{} }
func (*EmailProofByClientCert) ProtoMessage() {}
func (*EmailProofByClientCert) Descriptor() ([]byte, []int) {
	return fileDescriptorKeyserverconfig, []int{4}
}

// EmailProofByOIDC accepts an ID token fetched from an OpenID Connect provider
// and validates it as specified in the configuration. The token must have a
// valid signature, not expired, signed by the expected provider and must contain
// the expected Client ID
type EmailProofByOIDC struct {
	OIDCConfig []*OIDCConfig `protobuf:"bytes,1,rep,name=oidc_config,json=oidcConfig" json:"oidc_config,omitempty"`
}

func (m *EmailProofByOIDC) Reset()                    { *m = EmailProofByOIDC{} }
func (*EmailProofByOIDC) ProtoMessage()               {}
func (*EmailProofByOIDC) Descriptor() ([]byte, []int) { return fileDescriptorKeyserverconfig, []int{5} }

func (m *EmailProofByOIDC) GetOIDCConfig() []*OIDCConfig {
	if m != nil {
		return m.OIDCConfig
	}
	return nil
}

// EmailProofBySAML accepts the SAMLResponse signed by SAML2.0 Identity Provider
// as a sufficient confirmation of ownership of an email address. The email address
// must match the value of EmailAddress attribute in a valid SAMLResponse
type EmailProofBySAML struct {
	// AllowedDomains specifies the domains for which this keyserver accepts
	// email address registrations by this policy.
	AllowedDomains []string `protobuf:"bytes,1,rep,name=allowed_domains,json=allowedDomains" json:"allowed_domains,omitempty"`
	// IdPMetadataURL specifies the location of Identity Provider metadata
	// Identity provider's x509 cert and SSO URL is included in this metadata
	IDPMetadataURL string `protobuf:"bytes,2,opt,name=idp_metadata_url,json=idpMetadataUrl,proto3" json:"idp_metadata_url,omitempty"`
	// ConsumerServiceURL contains the AssertionConsumerServiceURL
	ConsumerServiceURL string    `protobuf:"bytes,4,opt,name=consumer_service_url,json=consumerServiceUrl,proto3" json:"consumer_service_url,omitempty"`
	ServiceProviderTLS TLSConfig `protobuf:"bytes,5,opt,name=service_provider_tls,json=serviceProviderTls" json:"service_provider_tls"`
	// Validity specifies the maximum amount of time the server is willing
	// to accept an assertion from the issue time in the assertion itself.
	// A zero value means server will only rely on the
	// SubjectConfirmationData.NotOnOrAfter field in the assertion.
	Validity Duration `protobuf:"bytes,6,opt,name=validity" json:"validity"`
}

func (m *EmailProofBySAML) Reset()                    { *m = EmailProofBySAML{} }
func (*EmailProofBySAML) ProtoMessage()               {}
func (*EmailProofBySAML) Descriptor() ([]byte, []int) { return fileDescriptorKeyserverconfig, []int{6} }

func (m *EmailProofBySAML) GetServiceProviderTLS() TLSConfig {
	if m != nil {
		return m.ServiceProviderTLS
	}
	return TLSConfig{}
}

func (m *EmailProofBySAML) GetValidity() Duration {
	if m != nil {
		return m.Validity
	}
	return Duration{}
}

// OIDCConfig contains the OpenID Connect client configuration which is used to
// validate the token received from the keyserver client.
type OIDCConfig struct {
	// AllowedDomains specifies the domains for which this keyserver accepts
	// email address registrations by this policy.
	AllowedDomains []string `protobuf:"bytes,1,rep,name=allowed_domains,json=allowedDomains" json:"allowed_domains,omitempty"`
	// DiscoveryURL specifies the location of OpenID Connect discovery document
	// as specified at http://openid.net/specs/openid-connect-discovery-1_0.html
	DiscoveryURL string `protobuf:"bytes,2,opt,name=discovery_url,json=discoveryUrl,proto3" json:"discovery_url,omitempty"`
	// Issuer specifies OpenID Connect issuer discovery url
	Issuer string `protobuf:"bytes,3,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// clientID specifies client's ID when the app is registered
	ClientID string `protobuf:"bytes,4,opt,name=clientID,proto3" json:"clientID,omitempty"`
	// Validity specifies the maximum amount of time the server is willing
	// to accept an OpenID Connect token from the issue time in the token itself.
	// A zero value means server will only rely on the expiry field in the token.
	Validity Duration `protobuf:"bytes,5,opt,name=validity" json:"validity"`
	// Scope specifies the OIDC scope
	Scope string `protobuf:"bytes,6,opt,name=scope,proto3" json:"scope,omitempty"`
}

func (m *OIDCConfig) Reset()                    { *m = OIDCConfig{} }
func (*OIDCConfig) ProtoMessage()               {}
func (*OIDCConfig) Descriptor() ([]byte, []int) { return fileDescriptorKeyserverconfig, []int{7} }

func (m *OIDCConfig) GetValidity() Duration {
	if m != nil {
		return m.Validity
	}
	return Duration{}
}

type Replica struct {
	// Id is used to distinguish between nodes during consistent replication.
	// All node ID-s MUST be unique, MUST NOT be reused (e.g., using IP-s or
	// hostnames is probably a bad idea) and SHOULD be set to the ID of the
	// first public key by convention.
	ID uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// PublicKeys lists the public keys of a node, to be joined using a
	// 1-out-of-n policy. The order of this list is NOT preserved.
	PublicKeys []*PublicKey `protobuf:"bytes,2,rep,name=public_keys,json=publicKeys" json:"public_keys,omitempty"`
	// RaftAddr is the Raft network address of the node, such that
	// net.Dial("tcp", Addr) reaches the node. Supported formats include
	// host.domain:port and ip:port.
	RaftAddr string `protobuf:"bytes,3,opt,name=raft_addr,json=raftAddr,proto3" json:"raft_addr,omitempty"`
}

func (m *Replica) Reset()                    { *m = Replica{} }
func (*Replica) ProtoMessage()               {}
func (*Replica) Descriptor() ([]byte, []int) { return fileDescriptorKeyserverconfig, []int{8} }

func (m *Replica) GetPublicKeys() []*PublicKey {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func init() {
	proto1.RegisterType((*ReplicaConfig)(nil), "proto.ReplicaConfig")
	proto1.RegisterType((*KeyserverConfig)(nil), "proto.KeyserverConfig")
	proto1.RegisterType((*RegistrationPolicy)(nil), "proto.RegistrationPolicy")
	proto1.RegisterType((*EmailProofByDKIM)(nil), "proto.EmailProofByDKIM")
	proto1.RegisterType((*EmailProofByClientCert)(nil), "proto.EmailProofByClientCert")
	proto1.RegisterType((*EmailProofByOIDC)(nil), "proto.EmailProofByOIDC")
	proto1.RegisterType((*EmailProofBySAML)(nil), "proto.EmailProofBySAML")
	proto1.RegisterType((*OIDCConfig)(nil), "proto.OIDCConfig")
	proto1.RegisterType((*Replica)(nil), "proto.Replica")
}
func (this *ReplicaConfig) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ReplicaConfig)
	if !ok {
		that2, ok := that.(ReplicaConfig)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ReplicaConfig")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ReplicaConfig but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ReplicaConfig but is not nil && this == nil")
	}
	if !this.KeyserverConfig.Equal(&that1.KeyserverConfig) {
		return fmt.Errorf("KeyserverConfig this(%v) Not Equal that(%v)", this.KeyserverConfig, that1.KeyserverConfig)
	}
	if this.ReplicaID != that1.ReplicaID {
		return fmt.Errorf("ReplicaID this(%v) Not Equal that(%v)", this.ReplicaID, that1.ReplicaID)
	}
	if this.SigningKeyID != that1.SigningKeyID {
		return fmt.Errorf("SigningKeyID this(%v) Not Equal that(%v)", this.SigningKeyID, that1.SigningKeyID)
	}
	if this.PublicAddr != that1.PublicAddr {
		return fmt.Errorf("PublicAddr this(%v) Not Equal that(%v)", this.PublicAddr, that1.PublicAddr)
	}
	if !this.PublicTLS.Equal(&that1.PublicTLS) {
		return fmt.Errorf("PublicTLS this(%v) Not Equal that(%v)", this.PublicTLS, that1.PublicTLS)
	}
	if this.VerifierAddr != that1.VerifierAddr {
		return fmt.Errorf("VerifierAddr this(%v) Not Equal that(%v)", this.VerifierAddr, that1.VerifierAddr)
	}
	if !this.VerifierTLS.Equal(&that1.VerifierTLS) {
		return fmt.Errorf("VerifierTLS this(%v) Not Equal that(%v)", this.VerifierTLS, that1.VerifierTLS)
	}
	if this.HKPAddr != that1.HKPAddr {
		return fmt.Errorf("HKPAddr this(%v) Not Equal that(%v)", this.HKPAddr, that1.HKPAddr)
	}
	if !this.HKPTLS.Equal(&that1.HKPTLS) {
		return fmt.Errorf("HKPTLS this(%v) Not Equal that(%v)", this.HKPTLS, that1.HKPTLS)
	}
	if this.HTTPFrontAddr != that1.HTTPFrontAddr {
		return fmt.Errorf("HTTPFrontAddr this(%v) Not Equal that(%v)", this.HTTPFrontAddr, that1.HTTPFrontAddr)
	}
	if !this.HTTPFrontTLS.Equal(&that1.HTTPFrontTLS) {
		return fmt.Errorf("HTTPFrontTLS this(%v) Not Equal that(%v)", this.HTTPFrontTLS, that1.HTTPFrontTLS)
	}
	if this.RaftAddr != that1.RaftAddr {
		return fmt.Errorf("RaftAddr this(%v) Not Equal that(%v)", this.RaftAddr, that1.RaftAddr)
	}
	if !this.RaftTLS.Equal(&that1.RaftTLS) {
		return fmt.Errorf("RaftTLS this(%v) Not Equal that(%v)", this.RaftTLS, that1.RaftTLS)
	}
	if this.LevelDBPath != that1.LevelDBPath {
		return fmt.Errorf("LevelDBPath this(%v) Not Equal that(%v)", this.LevelDBPath, that1.LevelDBPath)
	}
	if !this.RaftHeartbeat.Equal(&that1.RaftHeartbeat) {
		return fmt.Errorf("RaftHeartbeat this(%v) Not Equal that(%v)", this.RaftHeartbeat, that1.RaftHeartbeat)
	}
	if this.LaggingVerifierScan != that1.LaggingVerifierScan {
		return fmt.Errorf("LaggingVerifierScan this(%v) Not Equal that(%v)", this.LaggingVerifierScan, that1.LaggingVerifierScan)
	}
	if !this.ClientTimeout.Equal(&that1.ClientTimeout) {
		return fmt.Errorf("ClientTimeout this(%v) Not Equal that(%v)", this.ClientTimeout, that1.ClientTimeout)
	}
	return nil
}
func (this *ReplicaConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ReplicaConfig)
	if !ok {
		that2, ok := that.(ReplicaConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.KeyserverConfig.Equal(&that1.KeyserverConfig) {
		return false
	}
	if this.ReplicaID != that1.ReplicaID {
		return false
	}
	if this.SigningKeyID != that1.SigningKeyID {
		return false
	}
	if this.PublicAddr != that1.PublicAddr {
		return false
	}
	if !this.PublicTLS.Equal(&that1.PublicTLS) {
		return false
	}
	if this.VerifierAddr != that1.VerifierAddr {
		return false
	}
	if !this.VerifierTLS.Equal(&that1.VerifierTLS) {
		return false
	}
	if this.HKPAddr != that1.HKPAddr {
		return false
	}
	if !this.HKPTLS.Equal(&that1.HKPTLS) {
		return false
	}
	if this.HTTPFrontAddr != that1.HTTPFrontAddr {
		return false
	}
	if !this.HTTPFrontTLS.Equal(&that1.HTTPFrontTLS) {
		return false
	}
	if this.RaftAddr != that1.RaftAddr {
		return false
	}
	if !this.RaftTLS.Equal(&that1.RaftTLS) {
		return false
	}
	if this.LevelDBPath != that1.LevelDBPath {
		return false
	}
	if !this.RaftHeartbeat.Equal(&that1.RaftHeartbeat) {
		return false
	}
	if this.LaggingVerifierScan != that1.LaggingVerifierScan {
		return false
	}
	if !this.ClientTimeout.Equal(&that1.ClientTimeout) {
		return false
	}
	return true
}
func (this *KeyserverConfig) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*KeyserverConfig)
	if !ok {
		that2, ok := that.(KeyserverConfig)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *KeyserverConfig")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *KeyserverConfig but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *KeyserverConfig but is not nil && this == nil")
	}
	if this.ServerID != that1.ServerID {
		return fmt.Errorf("ServerID this(%v) Not Equal that(%v)", this.ServerID, that1.ServerID)
	}
	if this.Realm != that1.Realm {
		return fmt.Errorf("Realm this(%v) Not Equal that(%v)", this.Realm, that1.Realm)
	}
	if this.VRFKeyID != that1.VRFKeyID {
		return fmt.Errorf("VRFKeyID this(%v) Not Equal that(%v)", this.VRFKeyID, that1.VRFKeyID)
	}
	if !this.MinEpochInterval.Equal(&that1.MinEpochInterval) {
		return fmt.Errorf("MinEpochInterval this(%v) Not Equal that(%v)", this.MinEpochInterval, that1.MinEpochInterval)
	}
	if !this.MaxEpochInterval.Equal(&that1.MaxEpochInterval) {
		return fmt.Errorf("MaxEpochInterval this(%v) Not Equal that(%v)", this.MaxEpochInterval, that1.MaxEpochInterval)
	}
	if !this.ProposalRetryInterval.Equal(&that1.ProposalRetryInterval) {
		return fmt.Errorf("ProposalRetryInterval this(%v) Not Equal that(%v)", this.ProposalRetryInterval, that1.ProposalRetryInterval)
	}
	if len(this.InitialReplicas) != len(that1.InitialReplicas) {
		return fmt.Errorf("InitialReplicas this(%v) Not Equal that(%v)", len(this.InitialReplicas), len(that1.InitialReplicas))
	}
	for i := range this.InitialReplicas {
		if !this.InitialReplicas[i].Equal(that1.InitialReplicas[i]) {
			return fmt.Errorf("InitialReplicas this[%v](%v) Not Equal that[%v](%v)", i, this.InitialReplicas[i], i, that1.InitialReplicas[i])
		}
	}
	if len(this.RegistrationPolicy) != len(that1.RegistrationPolicy) {
		return fmt.Errorf("RegistrationPolicy this(%v) Not Equal that(%v)", len(this.RegistrationPolicy), len(that1.RegistrationPolicy))
	}
	for i := range this.RegistrationPolicy {
		if !this.RegistrationPolicy[i].Equal(that1.RegistrationPolicy[i]) {
			return fmt.Errorf("RegistrationPolicy this[%v](%v) Not Equal that[%v](%v)", i, this.RegistrationPolicy[i], i, that1.RegistrationPolicy[i])
		}
	}
	return nil
}
func (this *KeyserverConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*KeyserverConfig)
	if !ok {
		that2, ok := that.(KeyserverConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ServerID != that1.ServerID {
		return false
	}
	if this.Realm != that1.Realm {
		return false
	}
	if this.VRFKeyID != that1.VRFKeyID {
		return false
	}
	if !this.MinEpochInterval.Equal(&that1.MinEpochInterval) {
		return false
	}
	if !this.MaxEpochInterval.Equal(&that1.MaxEpochInterval) {
		return false
	}
	if !this.ProposalRetryInterval.Equal(&that1.ProposalRetryInterval) {
		return false
	}
	if len(this.InitialReplicas) != len(that1.InitialReplicas) {
		return false
	}
	for i := range this.InitialReplicas {
		if !this.InitialReplicas[i].Equal(that1.InitialReplicas[i]) {
			return false
		}
	}
	if len(this.RegistrationPolicy) != len(that1.RegistrationPolicy) {
		return false
	}
	for i := range this.RegistrationPolicy {
		if !this.RegistrationPolicy[i].Equal(that1.RegistrationPolicy[i]) {
			return false
		}
	}
	return true
}
func (this *RegistrationPolicy) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RegistrationPolicy)
	if !ok {
		that2, ok := that.(RegistrationPolicy)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RegistrationPolicy")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RegistrationPolicy but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RegistrationPolicy but is not nil && this == nil")
	}
	if that1.PolicyType == nil {
		if this.PolicyType != nil {
			return fmt.Errorf("this.PolicyType != nil && that1.PolicyType == nil")
		}
	} else if this.PolicyType == nil {
		return fmt.Errorf("this.PolicyType == nil && that1.PolicyType != nil")
	} else if err := this.PolicyType.VerboseEqual(that1.PolicyType); err != nil {
		return err
	}
	return nil
}
func (this *RegistrationPolicy_InsecureSkipEmailProof) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RegistrationPolicy_InsecureSkipEmailProof)
	if !ok {
		that2, ok := that.(RegistrationPolicy_InsecureSkipEmailProof)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RegistrationPolicy_InsecureSkipEmailProof")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RegistrationPolicy_InsecureSkipEmailProof but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RegistrationPolicy_InsecureSkipEmailProof but is not nil && this == nil")
	}
	if this.InsecureSkipEmailProof != that1.InsecureSkipEmailProof {
		return fmt.Errorf("InsecureSkipEmailProof this(%v) Not Equal that(%v)", this.InsecureSkipEmailProof, that1.InsecureSkipEmailProof)
	}
	return nil
}
func (this *RegistrationPolicy_EmailProofByDKIM) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RegistrationPolicy_EmailProofByDKIM)
	if !ok {
		that2, ok := that.(RegistrationPolicy_EmailProofByDKIM)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RegistrationPolicy_EmailProofByDKIM")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RegistrationPolicy_EmailProofByDKIM but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RegistrationPolicy_EmailProofByDKIM but is not nil && this == nil")
	}
	if !this.EmailProofByDKIM.Equal(that1.EmailProofByDKIM) {
		return fmt.Errorf("EmailProofByDKIM this(%v) Not Equal that(%v)", this.EmailProofByDKIM, that1.EmailProofByDKIM)
	}
	return nil
}
func (this *RegistrationPolicy_EmailProofByClientCert) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RegistrationPolicy_EmailProofByClientCert)
	if !ok {
		that2, ok := that.(RegistrationPolicy_EmailProofByClientCert)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RegistrationPolicy_EmailProofByClientCert")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RegistrationPolicy_EmailProofByClientCert but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RegistrationPolicy_EmailProofByClientCert but is not nil && this == nil")
	}
	if !this.EmailProofByClientCert.Equal(that1.EmailProofByClientCert) {
		return fmt.Errorf("EmailProofByClientCert this(%v) Not Equal that(%v)", this.EmailProofByClientCert, that1.EmailProofByClientCert)
	}
	return nil
}
func (this *RegistrationPolicy_EmailProofByOIDC) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RegistrationPolicy_EmailProofByOIDC)
	if !ok {
		that2, ok := that.(RegistrationPolicy_EmailProofByOIDC)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RegistrationPolicy_EmailProofByOIDC")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RegistrationPolicy_EmailProofByOIDC but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RegistrationPolicy_EmailProofByOIDC but is not nil && this == nil")
	}
	if !this.EmailProofByOIDC.Equal(that1.EmailProofByOIDC) {
		return fmt.Errorf("EmailProofByOIDC this(%v) Not Equal that(%v)", this.EmailProofByOIDC, that1.EmailProofByOIDC)
	}
	return nil
}
func (this *RegistrationPolicy_EmailProofBySAML) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RegistrationPolicy_EmailProofBySAML)
	if !ok {
		that2, ok := that.(RegistrationPolicy_EmailProofBySAML)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RegistrationPolicy_EmailProofBySAML")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RegistrationPolicy_EmailProofBySAML but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RegistrationPolicy_EmailProofBySAML but is not nil && this == nil")
	}
	if !this.EmailProofBySAML.Equal(that1.EmailProofBySAML) {
		return fmt.Errorf("EmailProofBySAML this(%v) Not Equal that(%v)", this.EmailProofBySAML, that1.EmailProofBySAML)
	}
	return nil
}
func (this *RegistrationPolicy) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RegistrationPolicy)
	if !ok {
		that2, ok := that.(RegistrationPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.PolicyType == nil {
		if this.PolicyType != nil {
			return false
		}
	} else if this.PolicyType == nil {
		return false
	} else if !this.PolicyType.Equal(that1.PolicyType) {
		return false
	}
	return true
}
func (this *RegistrationPolicy_InsecureSkipEmailProof) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RegistrationPolicy_InsecureSkipEmailProof)
	if !ok {
		that2, ok := that.(RegistrationPolicy_InsecureSkipEmailProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.InsecureSkipEmailProof != that1.InsecureSkipEmailProof {
		return false
	}
	return true
}
func (this *RegistrationPolicy_EmailProofByDKIM) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RegistrationPolicy_EmailProofByDKIM)
	if !ok {
		that2, ok := that.(RegistrationPolicy_EmailProofByDKIM)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.EmailProofByDKIM.Equal(that1.EmailProofByDKIM) {
		return false
	}
	return true
}
func (this *RegistrationPolicy_EmailProofByClientCert) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RegistrationPolicy_EmailProofByClientCert)
	if !ok {
		that2, ok := that.(RegistrationPolicy_EmailProofByClientCert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.EmailProofByClientCert.Equal(that1.EmailProofByClientCert) {
		return false
	}
	return true
}
func (this *RegistrationPolicy_EmailProofByOIDC) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RegistrationPolicy_EmailProofByOIDC)
	if !ok {
		that2, ok := that.(RegistrationPolicy_EmailProofByOIDC)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.EmailProofByOIDC.Equal(that1.EmailProofByOIDC) {
		return false
	}
	return true
}
func (this *RegistrationPolicy_EmailProofBySAML) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RegistrationPolicy_EmailProofBySAML)
	if !ok {
		that2, ok := that.(RegistrationPolicy_EmailProofBySAML)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.EmailProofBySAML.Equal(that1.EmailProofBySAML) {
		return false
	}
	return true
}
func (this *EmailProofByDKIM) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EmailProofByDKIM)
	if !ok {
		that2, ok := that.(EmailProofByDKIM)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *EmailProofByDKIM")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EmailProofByDKIM but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EmailProofByDKIM but is not nil && this == nil")
	}
	if len(this.AllowedDomains) != len(that1.AllowedDomains) {
		return fmt.Errorf("AllowedDomains this(%v) Not Equal that(%v)", len(this.AllowedDomains), len(that1.AllowedDomains))
	}
	for i := range this.AllowedDomains {
		if this.AllowedDomains[i] != that1.AllowedDomains[i] {
			return fmt.Errorf("AllowedDomains this[%v](%v) Not Equal that[%v](%v)", i, this.AllowedDomains[i], i, that1.AllowedDomains[i])
		}
	}
	if this.ToAddr != that1.ToAddr {
		return fmt.Errorf("ToAddr this(%v) Not Equal that(%v)", this.ToAddr, that1.ToAddr)
	}
	if this.SubjectPrefix != that1.SubjectPrefix {
		return fmt.Errorf("SubjectPrefix this(%v) Not Equal that(%v)", this.SubjectPrefix, that1.SubjectPrefix)
	}
	return nil
}
func (this *EmailProofByDKIM) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EmailProofByDKIM)
	if !ok {
		that2, ok := that.(EmailProofByDKIM)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.AllowedDomains) != len(that1.AllowedDomains) {
		return false
	}
	for i := range this.AllowedDomains {
		if this.AllowedDomains[i] != that1.AllowedDomains[i] {
			return false
		}
	}
	if this.ToAddr != that1.ToAddr {
		return false
	}
	if this.SubjectPrefix != that1.SubjectPrefix {
		return false
	}
	return true
}
func (this *EmailProofByClientCert) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EmailProofByClientCert)
	if !ok {
		that2, ok := that.(EmailProofByClientCert)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *EmailProofByClientCert")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EmailProofByClientCert but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EmailProofByClientCert but is not nil && this == nil")
	}
	if len(this.AllowedDomains) != len(that1.AllowedDomains) {
		return fmt.Errorf("AllowedDomains this(%v) Not Equal that(%v)", len(this.AllowedDomains), len(that1.AllowedDomains))
	}
	for i := range this.AllowedDomains {
		if this.AllowedDomains[i] != that1.AllowedDomains[i] {
			return fmt.Errorf("AllowedDomains this[%v](%v) Not Equal that[%v](%v)", i, this.AllowedDomains[i], i, that1.AllowedDomains[i])
		}
	}
	if !bytes.Equal(this.CaCert, that1.CaCert) {
		return fmt.Errorf("CaCert this(%v) Not Equal that(%v)", this.CaCert, that1.CaCert)
	}
	return nil
}
func (this *EmailProofByClientCert) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EmailProofByClientCert)
	if !ok {
		that2, ok := that.(EmailProofByClientCert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.AllowedDomains) != len(that1.AllowedDomains) {
		return false
	}
	for i := range this.AllowedDomains {
		if this.AllowedDomains[i] != that1.AllowedDomains[i] {
			return false
		}
	}
	if !bytes.Equal(this.CaCert, that1.CaCert) {
		return false
	}
	return true
}
func (this *EmailProofByOIDC) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EmailProofByOIDC)
	if !ok {
		that2, ok := that.(EmailProofByOIDC)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *EmailProofByOIDC")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EmailProofByOIDC but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EmailProofByOIDC but is not nil && this == nil")
	}
	if len(this.OIDCConfig) != len(that1.OIDCConfig) {
		return fmt.Errorf("OIDCConfig this(%v) Not Equal that(%v)", len(this.OIDCConfig), len(that1.OIDCConfig))
	}
	for i := range this.OIDCConfig {
		if !this.OIDCConfig[i].Equal(that1.OIDCConfig[i]) {
			return fmt.Errorf("OIDCConfig this[%v](%v) Not Equal that[%v](%v)", i, this.OIDCConfig[i], i, that1.OIDCConfig[i])
		}
	}
	return nil
}
func (this *EmailProofByOIDC) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EmailProofByOIDC)
	if !ok {
		that2, ok := that.(EmailProofByOIDC)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.OIDCConfig) != len(that1.OIDCConfig) {
		return false
	}
	for i := range this.OIDCConfig {
		if !this.OIDCConfig[i].Equal(that1.OIDCConfig[i]) {
			return false
		}
	}
	return true
}
func (this *EmailProofBySAML) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EmailProofBySAML)
	if !ok {
		that2, ok := that.(EmailProofBySAML)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *EmailProofBySAML")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EmailProofBySAML but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EmailProofBySAML but is not nil && this == nil")
	}
	if len(this.AllowedDomains) != len(that1.AllowedDomains) {
		return fmt.Errorf("AllowedDomains this(%v) Not Equal that(%v)", len(this.AllowedDomains), len(that1.AllowedDomains))
	}
	for i := range this.AllowedDomains {
		if this.AllowedDomains[i] != that1.AllowedDomains[i] {
			return fmt.Errorf("AllowedDomains this[%v](%v) Not Equal that[%v](%v)", i, this.AllowedDomains[i], i, that1.AllowedDomains[i])
		}
	}
	if this.IDPMetadataURL != that1.IDPMetadataURL {
		return fmt.Errorf("IDPMetadataURL this(%v) Not Equal that(%v)", this.IDPMetadataURL, that1.IDPMetadataURL)
	}
	if this.ConsumerServiceURL != that1.ConsumerServiceURL {
		return fmt.Errorf("ConsumerServiceURL this(%v) Not Equal that(%v)", this.ConsumerServiceURL, that1.ConsumerServiceURL)
	}
	if !this.ServiceProviderTLS.Equal(&that1.ServiceProviderTLS) {
		return fmt.Errorf("ServiceProviderTLS this(%v) Not Equal that(%v)", this.ServiceProviderTLS, that1.ServiceProviderTLS)
	}
	if !this.Validity.Equal(&that1.Validity) {
		return fmt.Errorf("Validity this(%v) Not Equal that(%v)", this.Validity, that1.Validity)
	}
	return nil
}
func (this *EmailProofBySAML) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EmailProofBySAML)
	if !ok {
		that2, ok := that.(EmailProofBySAML)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.AllowedDomains) != len(that1.AllowedDomains) {
		return false
	}
	for i := range this.AllowedDomains {
		if this.AllowedDomains[i] != that1.AllowedDomains[i] {
			return false
		}
	}
	if this.IDPMetadataURL != that1.IDPMetadataURL {
		return false
	}
	if this.ConsumerServiceURL != that1.ConsumerServiceURL {
		return false
	}
	if !this.ServiceProviderTLS.Equal(&that1.ServiceProviderTLS) {
		return false
	}
	if !this.Validity.Equal(&that1.Validity) {
		return false
	}
	return true
}
func (this *OIDCConfig) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OIDCConfig)
	if !ok {
		that2, ok := that.(OIDCConfig)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OIDCConfig")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OIDCConfig but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OIDCConfig but is not nil && this == nil")
	}
	if len(this.AllowedDomains) != len(that1.AllowedDomains) {
		return fmt.Errorf("AllowedDomains this(%v) Not Equal that(%v)", len(this.AllowedDomains), len(that1.AllowedDomains))
	}
	for i := range this.AllowedDomains {
		if this.AllowedDomains[i] != that1.AllowedDomains[i] {
			return fmt.Errorf("AllowedDomains this[%v](%v) Not Equal that[%v](%v)", i, this.AllowedDomains[i], i, that1.AllowedDomains[i])
		}
	}
	if this.DiscoveryURL != that1.DiscoveryURL {
		return fmt.Errorf("DiscoveryURL this(%v) Not Equal that(%v)", this.DiscoveryURL, that1.DiscoveryURL)
	}
	if this.Issuer != that1.Issuer {
		return fmt.Errorf("Issuer this(%v) Not Equal that(%v)", this.Issuer, that1.Issuer)
	}
	if this.ClientID != that1.ClientID {
		return fmt.Errorf("ClientID this(%v) Not Equal that(%v)", this.ClientID, that1.ClientID)
	}
	if !this.Validity.Equal(&that1.Validity) {
		return fmt.Errorf("Validity this(%v) Not Equal that(%v)", this.Validity, that1.Validity)
	}
	if this.Scope != that1.Scope {
		return fmt.Errorf("Scope this(%v) Not Equal that(%v)", this.Scope, that1.Scope)
	}
	return nil
}
func (this *OIDCConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OIDCConfig)
	if !ok {
		that2, ok := that.(OIDCConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.AllowedDomains) != len(that1.AllowedDomains) {
		return false
	}
	for i := range this.AllowedDomains {
		if this.AllowedDomains[i] != that1.AllowedDomains[i] {
			return false
		}
	}
	if this.DiscoveryURL != that1.DiscoveryURL {
		return false
	}
	if this.Issuer != that1.Issuer {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if !this.Validity.Equal(&that1.Validity) {
		return false
	}
	if this.Scope != that1.Scope {
		return false
	}
	return true
}
func (this *Replica) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Replica)
	if !ok {
		that2, ok := that.(Replica)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Replica")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Replica but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Replica but is not nil && this == nil")
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if len(this.PublicKeys) != len(that1.PublicKeys) {
		return fmt.Errorf("PublicKeys this(%v) Not Equal that(%v)", len(this.PublicKeys), len(that1.PublicKeys))
	}
	for i := range this.PublicKeys {
		if !this.PublicKeys[i].Equal(that1.PublicKeys[i]) {
			return fmt.Errorf("PublicKeys this[%v](%v) Not Equal that[%v](%v)", i, this.PublicKeys[i], i, that1.PublicKeys[i])
		}
	}
	if this.RaftAddr != that1.RaftAddr {
		return fmt.Errorf("RaftAddr this(%v) Not Equal that(%v)", this.RaftAddr, that1.RaftAddr)
	}
	return nil
}
func (this *Replica) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Replica)
	if !ok {
		that2, ok := that.(Replica)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if len(this.PublicKeys) != len(that1.PublicKeys) {
		return false
	}
	for i := range this.PublicKeys {
		if !this.PublicKeys[i].Equal(that1.PublicKeys[i]) {
			return false
		}
	}
	if this.RaftAddr != that1.RaftAddr {
		return false
	}
	return true
}
func (this *ReplicaConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&proto.ReplicaConfig{")
	s = append(s, "KeyserverConfig: "+strings.Replace(this.KeyserverConfig.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "ReplicaID: "+fmt.Sprintf("%#v", this.ReplicaID)+",\n")
	s = append(s, "SigningKeyID: "+fmt.Sprintf("%#v", this.SigningKeyID)+",\n")
	s = append(s, "PublicAddr: "+fmt.Sprintf("%#v", this.PublicAddr)+",\n")
	s = append(s, "PublicTLS: "+strings.Replace(this.PublicTLS.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "VerifierAddr: "+fmt.Sprintf("%#v", this.VerifierAddr)+",\n")
	s = append(s, "VerifierTLS: "+strings.Replace(this.VerifierTLS.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "HKPAddr: "+fmt.Sprintf("%#v", this.HKPAddr)+",\n")
	s = append(s, "HKPTLS: "+strings.Replace(this.HKPTLS.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "HTTPFrontAddr: "+fmt.Sprintf("%#v", this.HTTPFrontAddr)+",\n")
	s = append(s, "HTTPFrontTLS: "+strings.Replace(this.HTTPFrontTLS.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "RaftAddr: "+fmt.Sprintf("%#v", this.RaftAddr)+",\n")
	s = append(s, "RaftTLS: "+strings.Replace(this.RaftTLS.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "LevelDBPath: "+fmt.Sprintf("%#v", this.LevelDBPath)+",\n")
	s = append(s, "RaftHeartbeat: "+strings.Replace(this.RaftHeartbeat.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "LaggingVerifierScan: "+fmt.Sprintf("%#v", this.LaggingVerifierScan)+",\n")
	s = append(s, "ClientTimeout: "+strings.Replace(this.ClientTimeout.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KeyserverConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&proto.KeyserverConfig{")
	s = append(s, "ServerID: "+fmt.Sprintf("%#v", this.ServerID)+",\n")
	s = append(s, "Realm: "+fmt.Sprintf("%#v", this.Realm)+",\n")
	s = append(s, "VRFKeyID: "+fmt.Sprintf("%#v", this.VRFKeyID)+",\n")
	s = append(s, "MinEpochInterval: "+strings.Replace(this.MinEpochInterval.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "MaxEpochInterval: "+strings.Replace(this.MaxEpochInterval.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "ProposalRetryInterval: "+strings.Replace(this.ProposalRetryInterval.GoString(), `&`, ``, 1)+",\n")
	if this.InitialReplicas != nil {
		s = append(s, "InitialReplicas: "+fmt.Sprintf("%#v", this.InitialReplicas)+",\n")
	}
	if this.RegistrationPolicy != nil {
		s = append(s, "RegistrationPolicy: "+fmt.Sprintf("%#v", this.RegistrationPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegistrationPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto.RegistrationPolicy{")
	if this.PolicyType != nil {
		s = append(s, "PolicyType: "+fmt.Sprintf("%#v", this.PolicyType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegistrationPolicy_InsecureSkipEmailProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.RegistrationPolicy_InsecureSkipEmailProof{` +
		`InsecureSkipEmailProof:` + fmt.Sprintf("%#v", this.InsecureSkipEmailProof) + `}`}, ", ")
	return s
}
func (this *RegistrationPolicy_EmailProofByDKIM) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.RegistrationPolicy_EmailProofByDKIM{` +
		`EmailProofByDKIM:` + fmt.Sprintf("%#v", this.EmailProofByDKIM) + `}`}, ", ")
	return s
}
func (this *RegistrationPolicy_EmailProofByClientCert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.RegistrationPolicy_EmailProofByClientCert{` +
		`EmailProofByClientCert:` + fmt.Sprintf("%#v", this.EmailProofByClientCert) + `}`}, ", ")
	return s
}
func (this *RegistrationPolicy_EmailProofByOIDC) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.RegistrationPolicy_EmailProofByOIDC{` +
		`EmailProofByOIDC:` + fmt.Sprintf("%#v", this.EmailProofByOIDC) + `}`}, ", ")
	return s
}
func (this *RegistrationPolicy_EmailProofBySAML) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.RegistrationPolicy_EmailProofBySAML{` +
		`EmailProofBySAML:` + fmt.Sprintf("%#v", this.EmailProofBySAML) + `}`}, ", ")
	return s
}
func (this *EmailProofByDKIM) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.EmailProofByDKIM{")
	s = append(s, "AllowedDomains: "+fmt.Sprintf("%#v", this.AllowedDomains)+",\n")
	s = append(s, "ToAddr: "+fmt.Sprintf("%#v", this.ToAddr)+",\n")
	s = append(s, "SubjectPrefix: "+fmt.Sprintf("%#v", this.SubjectPrefix)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EmailProofByClientCert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.EmailProofByClientCert{")
	s = append(s, "AllowedDomains: "+fmt.Sprintf("%#v", this.AllowedDomains)+",\n")
	s = append(s, "CaCert: "+fmt.Sprintf("%#v", this.CaCert)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EmailProofByOIDC) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.EmailProofByOIDC{")
	if this.OIDCConfig != nil {
		s = append(s, "OIDCConfig: "+fmt.Sprintf("%#v", this.OIDCConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EmailProofBySAML) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto.EmailProofBySAML{")
	s = append(s, "AllowedDomains: "+fmt.Sprintf("%#v", this.AllowedDomains)+",\n")
	s = append(s, "IDPMetadataURL: "+fmt.Sprintf("%#v", this.IDPMetadataURL)+",\n")
	s = append(s, "ConsumerServiceURL: "+fmt.Sprintf("%#v", this.ConsumerServiceURL)+",\n")
	s = append(s, "ServiceProviderTLS: "+strings.Replace(this.ServiceProviderTLS.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Validity: "+strings.Replace(this.Validity.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OIDCConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&proto.OIDCConfig{")
	s = append(s, "AllowedDomains: "+fmt.Sprintf("%#v", this.AllowedDomains)+",\n")
	s = append(s, "DiscoveryURL: "+fmt.Sprintf("%#v", this.DiscoveryURL)+",\n")
	s = append(s, "Issuer: "+fmt.Sprintf("%#v", this.Issuer)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Validity: "+strings.Replace(this.Validity.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Scope: "+fmt.Sprintf("%#v", this.Scope)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Replica) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.Replica{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	if this.PublicKeys != nil {
		s = append(s, "PublicKeys: "+fmt.Sprintf("%#v", this.PublicKeys)+",\n")
	}
	s = append(s, "RaftAddr: "+fmt.Sprintf("%#v", this.RaftAddr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringKeyserverconfig(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringKeyserverconfig(m github_com_maditya_protobuf_proto.Message) string {
	e := github_com_maditya_protobuf_proto.GetUnsafeExtensionsMap(m)
	if e == nil {
		return "nil"
	}
	s := "proto.NewUnsafeXXX_InternalExtensions(map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "})"
	return s
}
func (m *ReplicaConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReplicaConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.KeyserverConfig.Size()))
	n1, err := m.KeyserverConfig.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.ReplicaID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(m.ReplicaID))
	}
	if len(m.SigningKeyID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.SigningKeyID)))
		i += copy(data[i:], m.SigningKeyID)
	}
	if len(m.PublicAddr) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.PublicAddr)))
		i += copy(data[i:], m.PublicAddr)
	}
	data[i] = 0x2a
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.PublicTLS.Size()))
	n2, err := m.PublicTLS.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.VerifierAddr) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.VerifierAddr)))
		i += copy(data[i:], m.VerifierAddr)
	}
	data[i] = 0x3a
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.VerifierTLS.Size()))
	n3, err := m.VerifierTLS.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if len(m.HKPAddr) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.HKPAddr)))
		i += copy(data[i:], m.HKPAddr)
	}
	data[i] = 0x4a
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.HKPTLS.Size()))
	n4, err := m.HKPTLS.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.HTTPFrontAddr) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.HTTPFrontAddr)))
		i += copy(data[i:], m.HTTPFrontAddr)
	}
	data[i] = 0x5a
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.HTTPFrontTLS.Size()))
	n5, err := m.HTTPFrontTLS.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.RaftAddr) > 0 {
		data[i] = 0x62
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.RaftAddr)))
		i += copy(data[i:], m.RaftAddr)
	}
	data[i] = 0x6a
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.RaftTLS.Size()))
	n6, err := m.RaftTLS.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.LevelDBPath) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.LevelDBPath)))
		i += copy(data[i:], m.LevelDBPath)
	}
	data[i] = 0x7a
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.RaftHeartbeat.Size()))
	n7, err := m.RaftHeartbeat.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.LaggingVerifierScan != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(m.LaggingVerifierScan))
	}
	data[i] = 0x8a
	i++
	data[i] = 0x1
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.ClientTimeout.Size()))
	n8, err := m.ClientTimeout.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *KeyserverConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *KeyserverConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(m.ServerID))
	}
	if len(m.Realm) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.Realm)))
		i += copy(data[i:], m.Realm)
	}
	if len(m.VRFKeyID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.VRFKeyID)))
		i += copy(data[i:], m.VRFKeyID)
	}
	data[i] = 0x22
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.MinEpochInterval.Size()))
	n9, err := m.MinEpochInterval.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	data[i] = 0x2a
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.MaxEpochInterval.Size()))
	n10, err := m.MaxEpochInterval.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	data[i] = 0x32
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.ProposalRetryInterval.Size()))
	n11, err := m.ProposalRetryInterval.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if len(m.InitialReplicas) > 0 {
		for _, msg := range m.InitialReplicas {
			data[i] = 0x3a
			i++
			i = encodeVarintKeyserverconfig(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RegistrationPolicy) > 0 {
		for _, msg := range m.RegistrationPolicy {
			data[i] = 0x42
			i++
			i = encodeVarintKeyserverconfig(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RegistrationPolicy) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RegistrationPolicy) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PolicyType != nil {
		nn12, err := m.PolicyType.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	return i, nil
}

func (m *RegistrationPolicy_InsecureSkipEmailProof) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x8
	i++
	if m.InsecureSkipEmailProof {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	return i, nil
}
func (m *RegistrationPolicy_EmailProofByDKIM) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.EmailProofByDKIM != nil {
		data[i] = 0x12
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(m.EmailProofByDKIM.Size()))
		n13, err := m.EmailProofByDKIM.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *RegistrationPolicy_EmailProofByClientCert) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.EmailProofByClientCert != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(m.EmailProofByClientCert.Size()))
		n14, err := m.EmailProofByClientCert.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *RegistrationPolicy_EmailProofByOIDC) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.EmailProofByOIDC != nil {
		data[i] = 0x22
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(m.EmailProofByOIDC.Size()))
		n15, err := m.EmailProofByOIDC.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *RegistrationPolicy_EmailProofBySAML) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.EmailProofBySAML != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(m.EmailProofBySAML.Size()))
		n16, err := m.EmailProofBySAML.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *EmailProofByDKIM) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmailProofByDKIM) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllowedDomains) > 0 {
		for _, s := range m.AllowedDomains {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ToAddr) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.ToAddr)))
		i += copy(data[i:], m.ToAddr)
	}
	if len(m.SubjectPrefix) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.SubjectPrefix)))
		i += copy(data[i:], m.SubjectPrefix)
	}
	return i, nil
}

func (m *EmailProofByClientCert) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmailProofByClientCert) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllowedDomains) > 0 {
		for _, s := range m.AllowedDomains {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.CaCert) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.CaCert)))
		i += copy(data[i:], m.CaCert)
	}
	return i, nil
}

func (m *EmailProofByOIDC) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmailProofByOIDC) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OIDCConfig) > 0 {
		for _, msg := range m.OIDCConfig {
			data[i] = 0xa
			i++
			i = encodeVarintKeyserverconfig(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EmailProofBySAML) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmailProofBySAML) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllowedDomains) > 0 {
		for _, s := range m.AllowedDomains {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.IDPMetadataURL) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.IDPMetadataURL)))
		i += copy(data[i:], m.IDPMetadataURL)
	}
	if len(m.ConsumerServiceURL) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.ConsumerServiceURL)))
		i += copy(data[i:], m.ConsumerServiceURL)
	}
	data[i] = 0x2a
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.ServiceProviderTLS.Size()))
	n17, err := m.ServiceProviderTLS.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	data[i] = 0x32
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.Validity.Size()))
	n18, err := m.Validity.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	return i, nil
}

func (m *OIDCConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OIDCConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllowedDomains) > 0 {
		for _, s := range m.AllowedDomains {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.DiscoveryURL) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.DiscoveryURL)))
		i += copy(data[i:], m.DiscoveryURL)
	}
	if len(m.Issuer) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.Issuer)))
		i += copy(data[i:], m.Issuer)
	}
	if len(m.ClientID) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	data[i] = 0x2a
	i++
	i = encodeVarintKeyserverconfig(data, i, uint64(m.Validity.Size()))
	n19, err := m.Validity.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if len(m.Scope) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.Scope)))
		i += copy(data[i:], m.Scope)
	}
	return i, nil
}

func (m *Replica) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Replica) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(m.ID))
	}
	if len(m.PublicKeys) > 0 {
		for _, msg := range m.PublicKeys {
			data[i] = 0x12
			i++
			i = encodeVarintKeyserverconfig(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RaftAddr) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintKeyserverconfig(data, i, uint64(len(m.RaftAddr)))
		i += copy(data[i:], m.RaftAddr)
	}
	return i, nil
}

func encodeFixed64Keyserverconfig(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Keyserverconfig(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintKeyserverconfig(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedReplicaConfig(r randyKeyserverconfig, easy bool) *ReplicaConfig {
	this := &ReplicaConfig{}
	v1 := NewPopulatedKeyserverConfig(r, easy)
	this.KeyserverConfig = *v1
	this.ReplicaID = uint64(uint64(r.Uint32()))
	this.SigningKeyID = randStringKeyserverconfig(r)
	this.PublicAddr = randStringKeyserverconfig(r)
	v2 := NewPopulatedTLSConfig(r, easy)
	this.PublicTLS = *v2
	this.VerifierAddr = randStringKeyserverconfig(r)
	v3 := NewPopulatedTLSConfig(r, easy)
	this.VerifierTLS = *v3
	this.HKPAddr = randStringKeyserverconfig(r)
	v4 := NewPopulatedTLSConfig(r, easy)
	this.HKPTLS = *v4
	this.HTTPFrontAddr = randStringKeyserverconfig(r)
	v5 := NewPopulatedTLSConfig(r, easy)
	this.HTTPFrontTLS = *v5
	this.RaftAddr = randStringKeyserverconfig(r)
	v6 := NewPopulatedTLSConfig(r, easy)
	this.RaftTLS = *v6
	this.LevelDBPath = randStringKeyserverconfig(r)
	v7 := NewPopulatedDuration(r, easy)
	this.RaftHeartbeat = *v7
	this.LaggingVerifierScan = uint64(uint64(r.Uint32()))
	v8 := NewPopulatedDuration(r, easy)
	this.ClientTimeout = *v8
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedKeyserverConfig(r randyKeyserverconfig, easy bool) *KeyserverConfig {
	this := &KeyserverConfig{}
	this.ServerID = uint64(uint64(r.Uint32()))
	this.Realm = randStringKeyserverconfig(r)
	this.VRFKeyID = randStringKeyserverconfig(r)
	v9 := NewPopulatedDuration(r, easy)
	this.MinEpochInterval = *v9
	v10 := NewPopulatedDuration(r, easy)
	this.MaxEpochInterval = *v10
	v11 := NewPopulatedDuration(r, easy)
	this.ProposalRetryInterval = *v11
	if r.Intn(10) != 0 {
		v12 := r.Intn(5)
		this.InitialReplicas = make([]*Replica, v12)
		for i := 0; i < v12; i++ {
			this.InitialReplicas[i] = NewPopulatedReplica(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.RegistrationPolicy = make([]*RegistrationPolicy, v13)
		for i := 0; i < v13; i++ {
			this.RegistrationPolicy[i] = NewPopulatedRegistrationPolicy(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRegistrationPolicy(r randyKeyserverconfig, easy bool) *RegistrationPolicy {
	this := &RegistrationPolicy{}
	oneofNumber_PolicyType := []int32{1, 2, 3, 4, 5}[r.Intn(5)]
	switch oneofNumber_PolicyType {
	case 1:
		this.PolicyType = NewPopulatedRegistrationPolicy_InsecureSkipEmailProof(r, easy)
	case 2:
		this.PolicyType = NewPopulatedRegistrationPolicy_EmailProofByDKIM(r, easy)
	case 3:
		this.PolicyType = NewPopulatedRegistrationPolicy_EmailProofByClientCert(r, easy)
	case 4:
		this.PolicyType = NewPopulatedRegistrationPolicy_EmailProofByOIDC(r, easy)
	case 5:
		this.PolicyType = NewPopulatedRegistrationPolicy_EmailProofBySAML(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRegistrationPolicy_InsecureSkipEmailProof(r randyKeyserverconfig, easy bool) *RegistrationPolicy_InsecureSkipEmailProof {
	this := &RegistrationPolicy_InsecureSkipEmailProof{}
	this.InsecureSkipEmailProof = bool(bool(r.Intn(2) == 0))
	return this
}
func NewPopulatedRegistrationPolicy_EmailProofByDKIM(r randyKeyserverconfig, easy bool) *RegistrationPolicy_EmailProofByDKIM {
	this := &RegistrationPolicy_EmailProofByDKIM{}
	this.EmailProofByDKIM = NewPopulatedEmailProofByDKIM(r, easy)
	return this
}
func NewPopulatedRegistrationPolicy_EmailProofByClientCert(r randyKeyserverconfig, easy bool) *RegistrationPolicy_EmailProofByClientCert {
	this := &RegistrationPolicy_EmailProofByClientCert{}
	this.EmailProofByClientCert = NewPopulatedEmailProofByClientCert(r, easy)
	return this
}
func NewPopulatedRegistrationPolicy_EmailProofByOIDC(r randyKeyserverconfig, easy bool) *RegistrationPolicy_EmailProofByOIDC {
	this := &RegistrationPolicy_EmailProofByOIDC{}
	this.EmailProofByOIDC = NewPopulatedEmailProofByOIDC(r, easy)
	return this
}
func NewPopulatedRegistrationPolicy_EmailProofBySAML(r randyKeyserverconfig, easy bool) *RegistrationPolicy_EmailProofBySAML {
	this := &RegistrationPolicy_EmailProofBySAML{}
	this.EmailProofBySAML = NewPopulatedEmailProofBySAML(r, easy)
	return this
}
func NewPopulatedEmailProofByDKIM(r randyKeyserverconfig, easy bool) *EmailProofByDKIM {
	this := &EmailProofByDKIM{}
	v14 := r.Intn(10)
	this.AllowedDomains = make([]string, v14)
	for i := 0; i < v14; i++ {
		this.AllowedDomains[i] = randStringKeyserverconfig(r)
	}
	this.ToAddr = randStringKeyserverconfig(r)
	this.SubjectPrefix = randStringKeyserverconfig(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEmailProofByClientCert(r randyKeyserverconfig, easy bool) *EmailProofByClientCert {
	this := &EmailProofByClientCert{}
	v15 := r.Intn(10)
	this.AllowedDomains = make([]string, v15)
	for i := 0; i < v15; i++ {
		this.AllowedDomains[i] = randStringKeyserverconfig(r)
	}
	v16 := r.Intn(100)
	this.CaCert = make([]byte, v16)
	for i := 0; i < v16; i++ {
		this.CaCert[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEmailProofByOIDC(r randyKeyserverconfig, easy bool) *EmailProofByOIDC {
	this := &EmailProofByOIDC{}
	if r.Intn(10) != 0 {
		v17 := r.Intn(5)
		this.OIDCConfig = make([]*OIDCConfig, v17)
		for i := 0; i < v17; i++ {
			this.OIDCConfig[i] = NewPopulatedOIDCConfig(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEmailProofBySAML(r randyKeyserverconfig, easy bool) *EmailProofBySAML {
	this := &EmailProofBySAML{}
	v18 := r.Intn(10)
	this.AllowedDomains = make([]string, v18)
	for i := 0; i < v18; i++ {
		this.AllowedDomains[i] = randStringKeyserverconfig(r)
	}
	this.IDPMetadataURL = randStringKeyserverconfig(r)
	this.ConsumerServiceURL = randStringKeyserverconfig(r)
	v19 := NewPopulatedTLSConfig(r, easy)
	this.ServiceProviderTLS = *v19
	v20 := NewPopulatedDuration(r, easy)
	this.Validity = *v20
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOIDCConfig(r randyKeyserverconfig, easy bool) *OIDCConfig {
	this := &OIDCConfig{}
	v21 := r.Intn(10)
	this.AllowedDomains = make([]string, v21)
	for i := 0; i < v21; i++ {
		this.AllowedDomains[i] = randStringKeyserverconfig(r)
	}
	this.DiscoveryURL = randStringKeyserverconfig(r)
	this.Issuer = randStringKeyserverconfig(r)
	this.ClientID = randStringKeyserverconfig(r)
	v22 := NewPopulatedDuration(r, easy)
	this.Validity = *v22
	this.Scope = randStringKeyserverconfig(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReplica(r randyKeyserverconfig, easy bool) *Replica {
	this := &Replica{}
	this.ID = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		v23 := r.Intn(5)
		this.PublicKeys = make([]*PublicKey, v23)
		for i := 0; i < v23; i++ {
			this.PublicKeys[i] = NewPopulatedPublicKey(r, easy)
		}
	}
	this.RaftAddr = randStringKeyserverconfig(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyKeyserverconfig interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneKeyserverconfig(r randyKeyserverconfig) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringKeyserverconfig(r randyKeyserverconfig) string {
	v24 := r.Intn(100)
	tmps := make([]rune, v24)
	for i := 0; i < v24; i++ {
		tmps[i] = randUTF8RuneKeyserverconfig(r)
	}
	return string(tmps)
}
func randUnrecognizedKeyserverconfig(r randyKeyserverconfig, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldKeyserverconfig(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldKeyserverconfig(data []byte, r randyKeyserverconfig, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateKeyserverconfig(data, uint64(key))
		v25 := r.Int63()
		if r.Intn(2) == 0 {
			v25 *= -1
		}
		data = encodeVarintPopulateKeyserverconfig(data, uint64(v25))
	case 1:
		data = encodeVarintPopulateKeyserverconfig(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateKeyserverconfig(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateKeyserverconfig(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateKeyserverconfig(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateKeyserverconfig(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *ReplicaConfig) Size() (n int) {
	var l int
	_ = l
	l = m.KeyserverConfig.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	if m.ReplicaID != 0 {
		n += 1 + sovKeyserverconfig(uint64(m.ReplicaID))
	}
	l = len(m.SigningKeyID)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = len(m.PublicAddr)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = m.PublicTLS.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	l = len(m.VerifierAddr)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = m.VerifierTLS.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	l = len(m.HKPAddr)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = m.HKPTLS.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	l = len(m.HTTPFrontAddr)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = m.HTTPFrontTLS.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	l = len(m.RaftAddr)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = m.RaftTLS.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	l = len(m.LevelDBPath)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = m.RaftHeartbeat.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	if m.LaggingVerifierScan != 0 {
		n += 2 + sovKeyserverconfig(uint64(m.LaggingVerifierScan))
	}
	l = m.ClientTimeout.Size()
	n += 2 + l + sovKeyserverconfig(uint64(l))
	return n
}

func (m *KeyserverConfig) Size() (n int) {
	var l int
	_ = l
	if m.ServerID != 0 {
		n += 1 + sovKeyserverconfig(uint64(m.ServerID))
	}
	l = len(m.Realm)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = len(m.VRFKeyID)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = m.MinEpochInterval.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	l = m.MaxEpochInterval.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	l = m.ProposalRetryInterval.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	if len(m.InitialReplicas) > 0 {
		for _, e := range m.InitialReplicas {
			l = e.Size()
			n += 1 + l + sovKeyserverconfig(uint64(l))
		}
	}
	if len(m.RegistrationPolicy) > 0 {
		for _, e := range m.RegistrationPolicy {
			l = e.Size()
			n += 1 + l + sovKeyserverconfig(uint64(l))
		}
	}
	return n
}

func (m *RegistrationPolicy) Size() (n int) {
	var l int
	_ = l
	if m.PolicyType != nil {
		n += m.PolicyType.Size()
	}
	return n
}

func (m *RegistrationPolicy_InsecureSkipEmailProof) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *RegistrationPolicy_EmailProofByDKIM) Size() (n int) {
	var l int
	_ = l
	if m.EmailProofByDKIM != nil {
		l = m.EmailProofByDKIM.Size()
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	return n
}
func (m *RegistrationPolicy_EmailProofByClientCert) Size() (n int) {
	var l int
	_ = l
	if m.EmailProofByClientCert != nil {
		l = m.EmailProofByClientCert.Size()
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	return n
}
func (m *RegistrationPolicy_EmailProofByOIDC) Size() (n int) {
	var l int
	_ = l
	if m.EmailProofByOIDC != nil {
		l = m.EmailProofByOIDC.Size()
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	return n
}
func (m *RegistrationPolicy_EmailProofBySAML) Size() (n int) {
	var l int
	_ = l
	if m.EmailProofBySAML != nil {
		l = m.EmailProofBySAML.Size()
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	return n
}
func (m *EmailProofByDKIM) Size() (n int) {
	var l int
	_ = l
	if len(m.AllowedDomains) > 0 {
		for _, s := range m.AllowedDomains {
			l = len(s)
			n += 1 + l + sovKeyserverconfig(uint64(l))
		}
	}
	l = len(m.ToAddr)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = len(m.SubjectPrefix)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	return n
}

func (m *EmailProofByClientCert) Size() (n int) {
	var l int
	_ = l
	if len(m.AllowedDomains) > 0 {
		for _, s := range m.AllowedDomains {
			l = len(s)
			n += 1 + l + sovKeyserverconfig(uint64(l))
		}
	}
	l = len(m.CaCert)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	return n
}

func (m *EmailProofByOIDC) Size() (n int) {
	var l int
	_ = l
	if len(m.OIDCConfig) > 0 {
		for _, e := range m.OIDCConfig {
			l = e.Size()
			n += 1 + l + sovKeyserverconfig(uint64(l))
		}
	}
	return n
}

func (m *EmailProofBySAML) Size() (n int) {
	var l int
	_ = l
	if len(m.AllowedDomains) > 0 {
		for _, s := range m.AllowedDomains {
			l = len(s)
			n += 1 + l + sovKeyserverconfig(uint64(l))
		}
	}
	l = len(m.IDPMetadataURL)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = len(m.ConsumerServiceURL)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = m.ServiceProviderTLS.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	l = m.Validity.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	return n
}

func (m *OIDCConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.AllowedDomains) > 0 {
		for _, s := range m.AllowedDomains {
			l = len(s)
			n += 1 + l + sovKeyserverconfig(uint64(l))
		}
	}
	l = len(m.DiscoveryURL)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	l = m.Validity.Size()
	n += 1 + l + sovKeyserverconfig(uint64(l))
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	return n
}

func (m *Replica) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovKeyserverconfig(uint64(m.ID))
	}
	if len(m.PublicKeys) > 0 {
		for _, e := range m.PublicKeys {
			l = e.Size()
			n += 1 + l + sovKeyserverconfig(uint64(l))
		}
	}
	l = len(m.RaftAddr)
	if l > 0 {
		n += 1 + l + sovKeyserverconfig(uint64(l))
	}
	return n
}

func sovKeyserverconfig(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozKeyserverconfig(x uint64) (n int) {
	return sovKeyserverconfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ReplicaConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplicaConfig{`,
		`KeyserverConfig:` + strings.Replace(strings.Replace(this.KeyserverConfig.String(), "KeyserverConfig", "KeyserverConfig", 1), `&`, ``, 1) + `,`,
		`ReplicaID:` + fmt.Sprintf("%v", this.ReplicaID) + `,`,
		`SigningKeyID:` + fmt.Sprintf("%v", this.SigningKeyID) + `,`,
		`PublicAddr:` + fmt.Sprintf("%v", this.PublicAddr) + `,`,
		`PublicTLS:` + strings.Replace(strings.Replace(this.PublicTLS.String(), "TLSConfig", "TLSConfig", 1), `&`, ``, 1) + `,`,
		`VerifierAddr:` + fmt.Sprintf("%v", this.VerifierAddr) + `,`,
		`VerifierTLS:` + strings.Replace(strings.Replace(this.VerifierTLS.String(), "TLSConfig", "TLSConfig", 1), `&`, ``, 1) + `,`,
		`HKPAddr:` + fmt.Sprintf("%v", this.HKPAddr) + `,`,
		`HKPTLS:` + strings.Replace(strings.Replace(this.HKPTLS.String(), "TLSConfig", "TLSConfig", 1), `&`, ``, 1) + `,`,
		`HTTPFrontAddr:` + fmt.Sprintf("%v", this.HTTPFrontAddr) + `,`,
		`HTTPFrontTLS:` + strings.Replace(strings.Replace(this.HTTPFrontTLS.String(), "TLSConfig", "TLSConfig", 1), `&`, ``, 1) + `,`,
		`RaftAddr:` + fmt.Sprintf("%v", this.RaftAddr) + `,`,
		`RaftTLS:` + strings.Replace(strings.Replace(this.RaftTLS.String(), "TLSConfig", "TLSConfig", 1), `&`, ``, 1) + `,`,
		`LevelDBPath:` + fmt.Sprintf("%v", this.LevelDBPath) + `,`,
		`RaftHeartbeat:` + strings.Replace(strings.Replace(this.RaftHeartbeat.String(), "Duration", "Duration", 1), `&`, ``, 1) + `,`,
		`LaggingVerifierScan:` + fmt.Sprintf("%v", this.LaggingVerifierScan) + `,`,
		`ClientTimeout:` + strings.Replace(strings.Replace(this.ClientTimeout.String(), "Duration", "Duration", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KeyserverConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KeyserverConfig{`,
		`ServerID:` + fmt.Sprintf("%v", this.ServerID) + `,`,
		`Realm:` + fmt.Sprintf("%v", this.Realm) + `,`,
		`VRFKeyID:` + fmt.Sprintf("%v", this.VRFKeyID) + `,`,
		`MinEpochInterval:` + strings.Replace(strings.Replace(this.MinEpochInterval.String(), "Duration", "Duration", 1), `&`, ``, 1) + `,`,
		`MaxEpochInterval:` + strings.Replace(strings.Replace(this.MaxEpochInterval.String(), "Duration", "Duration", 1), `&`, ``, 1) + `,`,
		`ProposalRetryInterval:` + strings.Replace(strings.Replace(this.ProposalRetryInterval.String(), "Duration", "Duration", 1), `&`, ``, 1) + `,`,
		`InitialReplicas:` + strings.Replace(fmt.Sprintf("%v", this.InitialReplicas), "Replica", "Replica", 1) + `,`,
		`RegistrationPolicy:` + strings.Replace(fmt.Sprintf("%v", this.RegistrationPolicy), "RegistrationPolicy", "RegistrationPolicy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegistrationPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegistrationPolicy{`,
		`PolicyType:` + fmt.Sprintf("%v", this.PolicyType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegistrationPolicy_InsecureSkipEmailProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegistrationPolicy_InsecureSkipEmailProof{`,
		`InsecureSkipEmailProof:` + fmt.Sprintf("%v", this.InsecureSkipEmailProof) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegistrationPolicy_EmailProofByDKIM) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegistrationPolicy_EmailProofByDKIM{`,
		`EmailProofByDKIM:` + strings.Replace(fmt.Sprintf("%v", this.EmailProofByDKIM), "EmailProofByDKIM", "EmailProofByDKIM", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegistrationPolicy_EmailProofByClientCert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegistrationPolicy_EmailProofByClientCert{`,
		`EmailProofByClientCert:` + strings.Replace(fmt.Sprintf("%v", this.EmailProofByClientCert), "EmailProofByClientCert", "EmailProofByClientCert", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegistrationPolicy_EmailProofByOIDC) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegistrationPolicy_EmailProofByOIDC{`,
		`EmailProofByOIDC:` + strings.Replace(fmt.Sprintf("%v", this.EmailProofByOIDC), "EmailProofByOIDC", "EmailProofByOIDC", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegistrationPolicy_EmailProofBySAML) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegistrationPolicy_EmailProofBySAML{`,
		`EmailProofBySAML:` + strings.Replace(fmt.Sprintf("%v", this.EmailProofBySAML), "EmailProofBySAML", "EmailProofBySAML", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmailProofByDKIM) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmailProofByDKIM{`,
		`AllowedDomains:` + fmt.Sprintf("%v", this.AllowedDomains) + `,`,
		`ToAddr:` + fmt.Sprintf("%v", this.ToAddr) + `,`,
		`SubjectPrefix:` + fmt.Sprintf("%v", this.SubjectPrefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmailProofByClientCert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmailProofByClientCert{`,
		`AllowedDomains:` + fmt.Sprintf("%v", this.AllowedDomains) + `,`,
		`CaCert:` + fmt.Sprintf("%v", this.CaCert) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmailProofByOIDC) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmailProofByOIDC{`,
		`OIDCConfig:` + strings.Replace(fmt.Sprintf("%v", this.OIDCConfig), "OIDCConfig", "OIDCConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmailProofBySAML) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmailProofBySAML{`,
		`AllowedDomains:` + fmt.Sprintf("%v", this.AllowedDomains) + `,`,
		`IDPMetadataURL:` + fmt.Sprintf("%v", this.IDPMetadataURL) + `,`,
		`ConsumerServiceURL:` + fmt.Sprintf("%v", this.ConsumerServiceURL) + `,`,
		`ServiceProviderTLS:` + strings.Replace(strings.Replace(this.ServiceProviderTLS.String(), "TLSConfig", "TLSConfig", 1), `&`, ``, 1) + `,`,
		`Validity:` + strings.Replace(strings.Replace(this.Validity.String(), "Duration", "Duration", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OIDCConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCConfig{`,
		`AllowedDomains:` + fmt.Sprintf("%v", this.AllowedDomains) + `,`,
		`DiscoveryURL:` + fmt.Sprintf("%v", this.DiscoveryURL) + `,`,
		`Issuer:` + fmt.Sprintf("%v", this.Issuer) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Validity:` + strings.Replace(strings.Replace(this.Validity.String(), "Duration", "Duration", 1), `&`, ``, 1) + `,`,
		`Scope:` + fmt.Sprintf("%v", this.Scope) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Replica) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Replica{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`PublicKeys:` + strings.Replace(fmt.Sprintf("%v", this.PublicKeys), "PublicKey", "PublicKey", 1) + `,`,
		`RaftAddr:` + fmt.Sprintf("%v", this.RaftAddr) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringKeyserverconfig(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ReplicaConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeyserverconfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyserverConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.KeyserverConfig.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReplicaID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningKeyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigningKeyID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicAddr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicTLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PublicTLS.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifierAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifierAddr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifierTLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VerifierTLS.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HKPAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HKPAddr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HKPTLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HKPTLS.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTPFrontAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTPFrontAddr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTPFrontTLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HTTPFrontTLS.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftAddr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftTLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftTLS.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelDBPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LevelDBPath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftHeartbeat.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaggingVerifierScan", wireType)
			}
			m.LaggingVerifierScan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LaggingVerifierScan |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClientTimeout.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeyserverconfig(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyserverConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeyserverconfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyserverConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyserverConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			m.ServerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ServerID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Realm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Realm = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VRFKeyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VRFKeyID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinEpochInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinEpochInterval.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEpochInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxEpochInterval.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalRetryInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProposalRetryInterval.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialReplicas = append(m.InitialReplicas, &Replica{})
			if err := m.InitialReplicas[len(m.InitialReplicas)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegistrationPolicy = append(m.RegistrationPolicy, &RegistrationPolicy{})
			if err := m.RegistrationPolicy[len(m.RegistrationPolicy)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeyserverconfig(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegistrationPolicy) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeyserverconfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegistrationPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegistrationPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsecureSkipEmailProof", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PolicyType = &RegistrationPolicy_InsecureSkipEmailProof{b}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailProofByDKIM", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EmailProofByDKIM{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicyType = &RegistrationPolicy_EmailProofByDKIM{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailProofByClientCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EmailProofByClientCert{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicyType = &RegistrationPolicy_EmailProofByClientCert{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailProofByOIDC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EmailProofByOIDC{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicyType = &RegistrationPolicy_EmailProofByOIDC{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailProofBySAML", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EmailProofBySAML{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicyType = &RegistrationPolicy_EmailProofBySAML{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeyserverconfig(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailProofByDKIM) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeyserverconfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailProofByDKIM: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailProofByDKIM: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedDomains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedDomains = append(m.AllowedDomains, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubjectPrefix = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeyserverconfig(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailProofByClientCert) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeyserverconfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailProofByClientCert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailProofByClientCert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedDomains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedDomains = append(m.AllowedDomains, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaCert = append(m.CaCert[:0], data[iNdEx:postIndex]...)
			if m.CaCert == nil {
				m.CaCert = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeyserverconfig(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailProofByOIDC) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeyserverconfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailProofByOIDC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailProofByOIDC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OIDCConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OIDCConfig = append(m.OIDCConfig, &OIDCConfig{})
			if err := m.OIDCConfig[len(m.OIDCConfig)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeyserverconfig(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailProofBySAML) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeyserverconfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailProofBySAML: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailProofBySAML: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedDomains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedDomains = append(m.AllowedDomains, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDPMetadataURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IDPMetadataURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerServiceURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerServiceURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProviderTLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceProviderTLS.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Validity.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeyserverconfig(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OIDCConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeyserverconfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedDomains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedDomains = append(m.AllowedDomains, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscoveryURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Validity.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeyserverconfig(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Replica) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeyserverconfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeys = append(m.PublicKeys, &PublicKey{})
			if err := m.PublicKeys[len(m.PublicKeys)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftAddr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeyserverconfig(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeyserverconfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKeyserverconfig(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKeyserverconfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKeyserverconfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthKeyserverconfig
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowKeyserverconfig
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipKeyserverconfig(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthKeyserverconfig = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKeyserverconfig   = fmt.Errorf("proto: integer overflow")
)

func init() { proto1.RegisterFile("keyserverconfig.proto", fileDescriptorKeyserverconfig) }

var fileDescriptorKeyserverconfig = []byte{
	// 1386 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x4b, 0x6f, 0x1b, 0xd5,
	0x17, 0xcf, 0xe4, 0xe1, 0xc7, 0xf1, 0x33, 0x37, 0x69, 0xea, 0xe6, 0xaf, 0xbf, 0x1d, 0x19, 0x01,
	0x01, 0xa1, 0x96, 0x06, 0x81, 0x5a, 0xd1, 0x4d, 0x27, 0x6e, 0x65, 0xe3, 0x44, 0xb5, 0xc6, 0xa1,
	0x0b, 0x90, 0x3a, 0xba, 0x9e, 0xb9, 0xb6, 0x2f, 0x1e, 0xcf, 0x0c, 0x77, 0xae, 0x4d, 0x2d, 0x36,
	0x7c, 0x1c, 0x3e, 0x02, 0x3b, 0x58, 0x76, 0xd9, 0x15, 0x62, 0x83, 0xd5, 0xcc, 0x8a, 0x65, 0x77,
	0xb0, 0x44, 0xf7, 0xe1, 0x49, 0xe2, 0x3c, 0x54, 0x56, 0xf6, 0x79, 0xfd, 0x7e, 0xe7, 0x9e, 0x39,
	0xe7, 0xde, 0x03, 0xb7, 0x46, 0x64, 0x16, 0x11, 0x36, 0x25, 0xcc, 0x09, 0xfc, 0x3e, 0x1d, 0xdc,
	0x0d, 0x59, 0xc0, 0x03, 0xb4, 0x21, 0x7f, 0x76, 0x3f, 0x1d, 0x50, 0x3e, 0x9c, 0xf4, 0xee, 0x3a,
	0xc1, 0xf8, 0xde, 0x18, 0xbb, 0x94, 0xcf, 0xf0, 0x3d, 0x69, 0xe9, 0x4d, 0xfa, 0xf7, 0x06, 0xc1,
	0x20, 0x90, 0x82, 0xfc, 0xa7, 0x02, 0x77, 0x4b, 0xdc, 0x8b, 0xce, 0x23, 0xed, 0x16, 0xdd, 0x09,
	0xc3, 0x9c, 0x06, 0xbe, 0x96, 0xf3, 0x8e, 0x47, 0x89, 0xcf, 0x95, 0x54, 0xff, 0x35, 0x0d, 0x05,
	0x8b, 0x84, 0x1e, 0x75, 0xf0, 0xa1, 0x8c, 0x42, 0x6d, 0x28, 0x27, 0x29, 0xd9, 0x0a, 0xa9, 0x62,
	0xec, 0x19, 0xfb, 0xb9, 0x83, 0x1d, 0x15, 0x73, 0xb7, 0xbd, 0x30, 0xab, 0x08, 0x33, 0xf3, 0x6a,
	0x5e, 0x5b, 0x79, 0x3d, 0xaf, 0x19, 0x56, 0x69, 0x74, 0xd1, 0x84, 0x3e, 0x01, 0x60, 0x0a, 0xdd,
	0xa6, 0x6e, 0x65, 0x75, 0xcf, 0xd8, 0x5f, 0x37, 0x0b, 0xf1, 0xbc, 0x96, 0xd5, 0x9c, 0xad, 0x86,
	0x95, 0xd5, 0x0e, 0x2d, 0x17, 0x7d, 0x01, 0xc5, 0x88, 0x0e, 0x7c, 0xea, 0x0f, 0xec, 0x11, 0x99,
	0x89, 0x88, 0xb5, 0x3d, 0x63, 0x3f, 0x6b, 0x96, 0xe3, 0x79, 0x2d, 0xdf, 0x55, 0x96, 0x36, 0x99,
	0xb5, 0x1a, 0x56, 0x3e, 0x3a, 0x93, 0x5c, 0x54, 0x83, 0x5c, 0x38, 0xe9, 0x79, 0xd4, 0xb1, 0xb1,
	0xeb, 0xb2, 0xca, 0xba, 0x08, 0xb2, 0x40, 0xa9, 0x1e, 0xbb, 0x2e, 0x43, 0x26, 0x68, 0xc9, 0xe6,
	0x5e, 0x54, 0xd9, 0x90, 0xa7, 0x29, 0xeb, 0xd3, 0x9c, 0x1c, 0x75, 0xf5, 0x39, 0x36, 0xc5, 0x39,
	0x44, 0x72, 0x1d, 0xe9, 0x7b, 0x72, 0xd4, 0xb5, 0xb2, 0x2a, 0xec, 0xc4, 0x8b, 0xd0, 0x7b, 0x50,
	0x98, 0x12, 0x46, 0xfb, 0x94, 0x30, 0x45, 0x93, 0x92, 0x34, 0xf9, 0x85, 0x52, 0x12, 0x35, 0x21,
	0x91, 0x25, 0x55, 0xfa, 0x1a, 0xaa, 0x2d, 0x4d, 0x95, 0x7b, 0xae, 0xbd, 0x05, 0x59, 0x6e, 0x11,
	0x2a, 0xe8, 0x3e, 0x80, 0xcc, 0x70, 0x14, 0x2a, 0xa6, 0x8c, 0xac, 0x42, 0x2e, 0x9e, 0xd7, 0xd2,
	0xcd, 0x76, 0x47, 0x10, 0x59, 0xe9, 0xe1, 0x28, 0x94, 0x8c, 0x0f, 0x41, 0xfc, 0x95, 0x64, 0xd9,
	0x6b, 0xc8, 0x8a, 0x9a, 0x2c, 0xd5, 0x6c, 0x77, 0x04, 0x4f, 0x6a, 0x38, 0x0a, 0x05, 0xc5, 0x03,
	0x28, 0x0e, 0x39, 0x0f, 0xfb, 0x2c, 0xf0, 0xb9, 0x22, 0x02, 0x49, 0xb4, 0x19, 0xcf, 0x6b, 0x85,
	0xe6, 0xc9, 0x49, 0xe7, 0xa9, 0xb0, 0x48, 0xba, 0x42, 0xe2, 0x28, 0x49, 0xdb, 0x70, 0xa6, 0x90,
	0xd4, 0xb9, 0x6b, 0xa8, 0xb7, 0x35, 0x75, 0x3e, 0x81, 0x13, 0x09, 0xe4, 0x93, 0x60, 0x91, 0xc6,
	0xff, 0x20, 0xcb, 0x70, 0x5f, 0x67, 0x90, 0x97, 0x45, 0xcd, 0x08, 0x85, 0x64, 0x7a, 0x04, 0xf2,
	0xbf, 0x24, 0x29, 0x5c, 0x43, 0x52, 0xd2, 0x24, 0x69, 0x0b, 0xf7, 0x25, 0x7e, 0x5a, 0x84, 0x08,
	0xe8, 0x03, 0xc8, 0x7b, 0x64, 0x4a, 0x3c, 0xb7, 0x67, 0x87, 0x98, 0x0f, 0x2b, 0x45, 0x79, 0xbe,
	0x92, 0x28, 0xfc, 0x91, 0xd0, 0x37, 0xcc, 0x0e, 0xe6, 0x43, 0x2b, 0xa7, 0x9d, 0x84, 0x80, 0x1e,
	0x41, 0x51, 0x32, 0x0e, 0x09, 0x66, 0xbc, 0x47, 0x30, 0xaf, 0x94, 0x24, 0x6f, 0x49, 0xf3, 0x36,
	0xf4, 0x38, 0x99, 0xeb, 0x82, 0xd6, 0x2a, 0x08, 0xe7, 0xe6, 0xc2, 0x17, 0x1d, 0xc0, 0x2d, 0x0f,
	0x0f, 0x06, 0xa2, 0x85, 0x93, 0x46, 0x88, 0x1c, 0xec, 0x57, 0xca, 0xa2, 0xf7, 0xad, 0x2d, 0x6d,
	0x5c, 0x7c, 0xf6, 0xae, 0x83, 0x7d, 0xc1, 0xa8, 0x66, 0xd2, 0xe6, 0x74, 0x4c, 0x82, 0x09, 0xaf,
	0x6c, 0xde, 0xc8, 0xa8, 0x9c, 0x4f, 0x94, 0x6f, 0x7d, 0xbe, 0x06, 0xa5, 0xa5, 0x89, 0x44, 0x1f,
	0x41, 0x56, 0x0f, 0x30, 0x75, 0xe5, 0xf0, 0xae, 0x9b, 0xf9, 0x78, 0x5e, 0xcb, 0x74, 0xa5, 0xb2,
	0xd5, 0xb0, 0x32, 0xca, 0xdc, 0x72, 0xd1, 0x36, 0x6c, 0x30, 0x82, 0xbd, 0xb1, 0x1c, 0xce, 0xac,
	0xa5, 0x04, 0xf4, 0x31, 0xc0, 0x94, 0xf5, 0x2f, 0x4e, 0xa1, 0x44, 0x78, 0x6e, 0x3d, 0x55, 0x13,
	0x98, 0x99, 0xb2, 0xbe, 0x9a, 0xbe, 0x43, 0x40, 0x63, 0xea, 0xdb, 0x24, 0x0c, 0x9c, 0xa1, 0x4d,
	0x7d, 0x4e, 0xd8, 0x14, 0x7b, 0x72, 0x08, 0xaf, 0x3d, 0x42, 0x79, 0x4c, 0xfd, 0x27, 0xc2, 0xbf,
	0xa5, 0xdd, 0x25, 0x08, 0x7e, 0xb9, 0x0c, 0xb2, 0x71, 0x33, 0x08, 0x7e, 0x79, 0x11, 0xe4, 0x18,
	0x6e, 0x87, 0x2c, 0x08, 0x83, 0x08, 0x7b, 0x36, 0x23, 0x9c, 0xcd, 0xce, 0x90, 0x52, 0x37, 0x21,
	0xdd, 0x5a, 0x44, 0x59, 0x22, 0x28, 0x81, 0x7b, 0x08, 0x65, 0xea, 0x53, 0x4e, 0x25, 0x9a, 0xbc,
	0xa3, 0xc4, 0x40, 0xaf, 0xed, 0xe7, 0x0e, 0x8a, 0x1a, 0x47, 0xdf, 0x62, 0x56, 0x49, 0xfb, 0x69,
	0x39, 0x42, 0x5f, 0xc1, 0x16, 0x23, 0x03, 0x1a, 0x71, 0xc5, 0x63, 0x87, 0x81, 0x47, 0x9d, 0x59,
	0x25, 0x23, 0xa3, 0xef, 0x24, 0xd1, 0x67, 0x1e, 0x1d, 0xe9, 0x60, 0x21, 0x76, 0x49, 0x57, 0xff,
	0x73, 0x0d, 0xd0, 0x65, 0x57, 0xf4, 0x25, 0xdc, 0xa1, 0x7e, 0x44, 0x9c, 0x09, 0x23, 0x76, 0x34,
	0xa2, 0xa1, 0x4d, 0xc6, 0x98, 0x7a, 0x76, 0xc8, 0x82, 0xa0, 0x2f, 0xbf, 0x79, 0xa6, 0xb9, 0x62,
	0xed, 0x2c, 0x5c, 0xba, 0x23, 0x1a, 0x3e, 0x11, 0x0e, 0x1d, 0x61, 0x47, 0x2f, 0x60, 0xeb, 0x9c,
	0xbb, 0xdd, 0x9b, 0xd9, 0xee, 0x88, 0xaa, 0x1e, 0xc8, 0x1d, 0xdc, 0xd6, 0xf9, 0x9d, 0xf9, 0x9b,
	0xb3, 0x46, 0xbb, 0x75, 0x6c, 0x6e, 0xc7, 0xf3, 0x5a, 0x79, 0x59, 0xdb, 0x5c, 0xb1, 0xca, 0xe4,
	0xbc, 0x6e, 0x44, 0xc7, 0xe8, 0x5b, 0xd8, 0x5d, 0xc2, 0xd7, 0x1d, 0xee, 0x10, 0xc6, 0x65, 0x3f,
	0xe5, 0x0e, 0xfe, 0x7f, 0x05, 0xcd, 0xa1, 0xf4, 0x3a, 0x24, 0x8c, 0x8b, 0xe4, 0xc9, 0x95, 0x96,
	0x2b, 0x92, 0x0f, 0xa8, 0xeb, 0xe8, 0x8e, 0xbb, 0x2a, 0xf9, 0x67, 0xad, 0xc6, 0xe1, 0xe5, 0xe4,
	0x85, 0x76, 0x39, 0xf9, 0x67, 0xd4, 0x75, 0xae, 0xc0, 0x8f, 0xf0, 0x78, 0xd1, 0x8c, 0x57, 0xe1,
	0x77, 0x1f, 0x1f, 0x1f, 0x5d, 0xc6, 0x17, 0xda, 0x65, 0xfc, 0x2e, 0x1e, 0x7b, 0x66, 0x01, 0x72,
	0xaa, 0x1f, 0x6c, 0x3e, 0x0b, 0x49, 0xfd, 0x47, 0xb8, 0x54, 0x53, 0xf4, 0x21, 0x94, 0xb0, 0xe7,
	0x05, 0x3f, 0x10, 0xd7, 0x76, 0x83, 0x31, 0xa6, 0x7e, 0x54, 0x31, 0xf6, 0xd6, 0xf6, 0xb3, 0x56,
	0x51, 0xab, 0x1b, 0x4a, 0x8b, 0x6e, 0x43, 0x9a, 0x07, 0xea, 0xea, 0x54, 0x03, 0x9c, 0xe2, 0x81,
	0xbc, 0x38, 0xdf, 0x87, 0x62, 0x34, 0xe9, 0x7d, 0x47, 0x1c, 0x6e, 0x87, 0x8c, 0xf4, 0xe9, 0x4b,
	0x35, 0xc5, 0x56, 0x41, 0x6b, 0x3b, 0x52, 0x59, 0xff, 0x06, 0x76, 0xae, 0xae, 0xff, 0x7f, 0x4a,
	0xc1, 0xc1, 0xea, 0xc3, 0x8a, 0x14, 0xf2, 0x56, 0xca, 0xc1, 0x02, 0xa1, 0xfe, 0x1c, 0x2e, 0xd5,
	0x1b, 0x99, 0x90, 0x13, 0x1f, 0xeb, 0x6c, 0xb1, 0x10, 0x03, 0xb1, 0xa9, 0x6b, 0x2a, 0x3c, 0x16,
	0x6f, 0x56, 0x3c, 0xaf, 0xc1, 0x99, 0x6c, 0x81, 0x88, 0x52, 0xff, 0xeb, 0xbf, 0xaf, 0xc2, 0xa5,
	0x42, 0xbf, 0x7b, 0xba, 0x8f, 0xa0, 0x4c, 0xdd, 0xd0, 0x1e, 0x13, 0x8e, 0x5d, 0xcc, 0xb1, 0x3d,
	0x61, 0x9e, 0x2a, 0x9d, 0x89, 0xe2, 0x79, 0xad, 0xd8, 0x6a, 0x74, 0x8e, 0xb5, 0xe9, 0x6b, 0xeb,
	0xc8, 0x2a, 0x52, 0x37, 0x4c, 0x64, 0xe6, 0xa1, 0x26, 0x6c, 0x3b, 0x81, 0x1f, 0x4d, 0xc6, 0xe2,
	0x5e, 0x27, 0x6c, 0x4a, 0x1d, 0x22, 0x11, 0xe4, 0xce, 0x61, 0xee, 0xc4, 0xf3, 0x1a, 0x3a, 0xd4,
	0xf6, 0xae, 0x32, 0x0b, 0x14, 0xe4, 0x2c, 0xe9, 0x98, 0x87, 0x5e, 0xc0, 0xf6, 0x02, 0x20, 0x64,
	0xc1, 0x94, 0xba, 0x7a, 0x65, 0xb8, 0x6e, 0x3b, 0xd9, 0xd5, 0xaf, 0x1c, 0xd2, 0x18, 0x1d, 0x1d,
	0x24, 0x1e, 0x3c, 0x14, 0x2d, 0xe9, 0xbc, 0x08, 0xdd, 0x87, 0xcc, 0x14, 0x7b, 0x54, 0xec, 0x8c,
	0x37, 0xdf, 0x7e, 0x89, 0x5b, 0xfd, 0x6f, 0x03, 0xce, 0xd5, 0xfc, 0xdd, 0x4b, 0xfa, 0x39, 0x14,
	0x5c, 0x1a, 0x39, 0xc1, 0x94, 0xb0, 0xd9, 0xb9, 0x7a, 0xca, 0xb5, 0xad, 0xb1, 0x30, 0x88, 0x3a,
	0xe4, 0x13, 0x37, 0x51, 0x81, 0x1d, 0x48, 0xd1, 0x28, 0x9a, 0x10, 0xa6, 0x5b, 0x53, 0x4b, 0x68,
	0x1f, 0x32, 0xea, 0xb6, 0x68, 0x35, 0x74, 0x5d, 0xe5, 0xd3, 0x73, 0xa8, 0x75, 0x56, 0x62, 0xbd,
	0x70, 0xc6, 0x8d, 0x77, 0x3a, 0xa3, 0x78, 0xef, 0x22, 0x27, 0x08, 0x89, 0x5e, 0xdf, 0x94, 0x50,
	0xff, 0x1e, 0xd2, 0xfa, 0xee, 0x46, 0x3b, 0xb0, 0x9a, 0x3c, 0x9a, 0xa9, 0x78, 0x5e, 0x5b, 0x6d,
	0x35, 0xac, 0x55, 0xea, 0xa2, 0xfb, 0xc9, 0x92, 0x29, 0x96, 0xdc, 0xca, 0xaa, 0xec, 0xdc, 0xc5,
	0x67, 0x52, 0x1b, 0x63, 0x9b, 0xcc, 0x16, 0x6b, 0xa7, 0x78, 0x91, 0x2f, 0x6e, 0x36, 0x6b, 0x17,
	0x37, 0x1b, 0xf3, 0xc1, 0xeb, 0xd3, 0xea, 0xca, 0x1f, 0xa7, 0xd5, 0x95, 0x37, 0xa7, 0x55, 0xe3,
	0xed, 0x69, 0xd5, 0xf8, 0xe7, 0xb4, 0x6a, 0xfc, 0x14, 0x57, 0x8d, 0x9f, 0xe3, 0xaa, 0xf1, 0x4b,
	0x5c, 0x35, 0x7e, 0x8b, 0xab, 0xc6, 0xab, 0xb8, 0x6a, 0xbc, 0x8e, 0xab, 0xc6, 0x9b, 0xb8, 0x6a,
	0xfc, 0x15, 0x57, 0x57, 0xde, 0xc6, 0x55, 0xa3, 0x97, 0x92, 0x9c, 0x9f, 0xfd, 0x1b, 0x00, 0x00,
	0xff, 0xff, 0x00, 0x59, 0xd5, 0xc0, 0x3b, 0x0c, 0x00, 0x00,
}
